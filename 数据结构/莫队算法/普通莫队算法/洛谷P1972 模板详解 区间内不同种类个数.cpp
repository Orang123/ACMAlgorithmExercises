#include<cstdio>
#include<cmath>
#include<algorithm>
#define N 1000100
#define M 1000100
using namespace std;
int a[N],pos[N],ans[M],cnt[N],res;

//莫队算法 是由前国家队队长莫涛提出,故城“莫队”算法 这题得用树状数组或线段树做 莫队被卡时,只有58分
//莫队是一种比较优雅的暴力算法,有尺取的味道.

struct seq{
    int l,r,id;
    bool operator < (const seq &x)const{
        /*//对于不在同一快,按块号排序,对于在同一块号按照区间右端点排序
        //之所以不同块按照块排序,不按照区间左端点排序,是因为若按照区间左端点排序,那么相邻的区间右端点之间差的也比较多,这样转移步数依然比较大
        //而对于相同块内 区间左端点可能也会有差距,但这个差距已经因为分块的块长,根号n降低了,所产生的额外转移步数大大降低，影响没有那么大了
        if(pos[l] != pos[x.l]) return pos[l]<pos[x.l];//貌似块不同时按照区间左端点排序会更快些即:return l<x.l;
        else return r<x.r;*/
        //优化版 块内奇偶化排序 对于上一个奇数块 若区间右端点是100,则下一个偶数块内,降序从右端点99开始降序,这样子 可以有效降低莫队转移步数
        /*
        eg:块长为2 如果偶数快不降序排列,则对于第三个询问,右端点需要多转移99步,
        而若偶数快降序排列则紧随着的第三个询问4 100右端点和之前的2 100是相同的,
        只需将左端点向右移动2步即可.能快30%左右.分块最主要的目的就是分出奇数块和偶数块,进行奇偶化排序以降低莫队每条询问转移的次数
        1 1     1 1
        2 100   2 100
        3 1     4 100
        4 100   3 1
        */
        //return pos[l]^pos[x.l]?pos[l]<pos[x.l]:(pos[l]^1?r<x.r:r>x.r);
        if(pos[l] != pos[x.l]) return pos[l]<pos[x.l];
        if(pos[l] & 1) return r<x.r;//奇数块 升序排,偶数块降序排
        else return r>x.r;
    }
}q[M];

void update(int id,int sign){
    int x=a[id];
    cnt[x]+=sign;
    /*
    若现在这种贝壳的种类只有1种,则种类数+1,否则则有重复 对于种类数大于1的cnt依然++，
    可结果res不加 等到去除这个边界点时,若cnt减完不为0,说明不同的种类个数还是要算在里面的,
    res结果并不变.
    */
    if(sign == 1 && cnt[x] == 1) res++;
    else if(sign == -1 & cnt[x] == 0) res--;//若现在这种贝壳种类数只剩1种,则种类数-1,否则
}

int main(){
    int n,m,siz;
    scanf("%d",&n);
    siz=sqrt(n);//块的大小为根号n,总共有根号n个块
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        pos[i]=(i-1)/siz+1;//下标为i的数所属的块的标号为pos[i] 感觉分块只是为了提高排序的效率,但是感觉好像不分块最后的序列更优,查询转移效率更高
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d",&q[i].l,&q[i].r);
        q[i].id=i;//询问的标号
    }
    /*
    将询问序列排序,这样莫队算法转移的效率才会高,转移的顺序刚好最为接近询问的区间,
    这些询问区间紧邻左右端点都紧邻着,那么区间lr不断转移,也不断接近下一个紧邻的区间.
    若不排序则每个询问区间,最坏都移动了O(n)次,则总的时间O(nm)
    比如询问区间若是[1,2]、[1,3]、[3,4]、[5,6]就是较好的序列,每次移动的步数较小
    而[1,2]、[5,6]、[1,3]、[3,4]整体所需移动的步数较前一种较多.
    */
    sort(q+1,q+1+m);
    int l=1,r=0;//转移的时候先扩张再收缩,L先向右,L再向左,最后再收缩.
    //离线处理m次询问,每次询问,每次转移只会将区间转移1位,即若知道区间[l,r]的值,则一次转移只会得到[l-1,r],[l+1,r],[l,r-1],[l,r+1]这四个区间的值
    //分块之后的排序和查询转移的时间复杂度为O(n*根号n) 转移的过程做法和尺取有点相像  最暴力不构建数据结构的办法是O(mn),就是从l到r做标记记录
    for(int i=1;i<=m;i++){
        while(l<q[i].l) /*if(--cnt[a[l++]] == 0) res--*/update(l++,-1);//不断将区间左端点(左指针)右移,直到和询问左端点重合,移除多余的左端点的种类个数,每次转移只会移动1位
        while(l>q[i].l) /*if(cnt[a[--l]]++ == 0) res++;*/update(--l,1);
        while(r<q[i].r) /*if(cnt[a[++r]]++ == 0) res++;*/update(++r,1);
        while(r>q[i].r) /*if(--cnt[a[r--]] == 0) res--;*/update(r--,-1);
        ans[q[i].id]=res;
    }
    for(int i=1;i<=m;i++)
        printf("%d\n",ans[i]);
    return 0;
}
