/*
题意:n颗星星,星星的等级为其左下的星星的个数
计算所有等级的星星的个数,星星按Y 坐标升序排列,
Y坐标相等的星星按X坐标升序排列.
星星坐标按Y升序,X升序给出.
n<=15000,0<=X<=32000.
链接:http://poj.org/problem?id=2352
思路:因为Y坐标本身就是升序输入的,因此可以将x坐标作为前缀和.
显然线性数组整体构造时间复杂度可达O(N*M)=4.8*10^8会TLE.
因此可以按照X坐标构造树状数组,这样更新查询时间复杂度都是O(log(M)),
构造时间复杂度为O(N*log(M))=2.25*10^5.
*/

/*
树状数组参考博客学习:
https://blog.csdn.net/int64ago/article/details/7429868
https://blog.csdn.net/ljd4305/article/details/10101535
https://www.cnblogs.com/fusiwei/p/11275978.html
https://www.cnblogs.com/xenny/p/9739600.html
//C[i]是子树父节点的累加和,A[i]是数组中每个元素的值
C[1] = A[1];
C[2] = A[1] + A[2];
C[3] = A[3];
C[4] = A[1] + A[2] + A[3] + A[4];
C[5] = A[5];
C[6] = A[5] + A[6];
C[7] = A[7];
C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8];
C[i] = A[i - 2^k+1] + A[i - 2^k+2] + ... + A[i];   //k为i的二进制中从最低位到高位连续零的长度
其实就是对应二进制位中最低位1的幂次
*/

//ac 407ms 树状数组 查询和更新复杂度都为O(log(M)) 这里的M是横坐标上限不是星星个数
#include <stdio.h>
#define N 15100
#define M 32002
//注意树状数组的结构永远是恒定的就是那固定的一种结构
//这里是只保留x的二进制位最低位的1,比如对于十进制10,对应二进制1010,
//负十-10为按位取反+1结果0101+1=0110,1010&0110=0010结果就是只保留最低位的1
#define lowbit(x) ((x)&(-(x)))

int a[M],num[N];

//构造这颗子树时也是使用更新,而且对于区间长度为n时,
//由二进制位表示可看出所对应的树状数组中子树的个数最大为log(M),因此循环的次数最大也就为log(M)
void update(int *a,int p,int d){//O(log(M)) 这里的M是横坐标上限不是星星个数
    //p+=lowbit(p) 这里是找到p的父子树结点 依次更新父子树结点
	//这里在构造这个树桩数组时,对于树状数组中的每个结点而言它所保存的累积和并不一定就包括前面所有实际数组元素之和,
	//有可能也只是某一课子树所累加的个别元素的和,真正在求解区间和时,应该是通过x-lowbit(x)连续求解多棵子树的累积和
	for(;p<M; p+=lowbit(p)) a[p]+=d;
}

//求解区间和事实上这个没有绝对的时间界,取决于所求的区间是多大,
//某一个好的区间序列,有可能只需要o(1)就可求解出来,
//就是这个树状数组中的代号为二进制只有一个1,列如:8(1000).
//这个树状数组是前面所有子树的父节点,最坏的情况是区间长度最大为7(111)时,
//求解前7个元素的累积和,连续求解了3棵子树(4,6,7),最坏循环3次.
int getsum(int *a,int p){//O(log(M))
	int s = 0;
	//p-=lowbit(p) 这里是求解p以前的数组和,有可能是由多棵子树所构成的
	//eg:求解区间0~7的元素的和累积和 对于 7 0111 7-lowbit(7)=0110(6) 结果是
	//树状数组中代号6的那颗子树的累积和 而6-lowbit(6)=0100(4) 得到结果为 为树状数组中代号为4的那颗子树
	//直到减到 像 2 4 8 16这样只有一个二进制1的 相减后结果就为0,因为这些代号的子树就已经累计和包括了前面所有的元素
	for(; p; p-=lowbit(p)) s += a[p];
	return s;
}

int main(){
	int n,i,x,y;
	scanf("%d",&n);
	for(i=0;i<n;i++){//O(N*log(M)) 15000*15=2.25*10^5 1s时限可接受
		scanf("%d %d",&x,&y);
		//给的点的坐标是从0开始的,树状数组下标为0的位置不可用,所以我们需要在输入x坐标时+1.
		//如果y坐标上升,x坐标是下降的,那么这个点必然不在左下,因此不会对之前的结果造成影响.
		num[getsum(a,x+1)]++;//因为星星的等级不把自身算进去,因此先累加后更新
		update(a,x+1,1);
	}
	for(i=0;i<n;i++) printf("%d\n",num[i]);
	return 0;
}

/*
//TLE 线性数组 查询O(1 更新O(n)
#include <stdio.h>
#define N 15100
#define M 32002

int a[M],num[N];

//O(M)
void update(int *a,int p,int d){
	for(;p<M; p++) a[p]+=d;
}

int main(){
	int n,i,x,y;
	scanf("%d",&n);
	for(i=0;i<n;i++){//O(N*M) 15000*32000=4.8*10^8 TLE
		scanf("%d %d",&x,&y);
		num[a[x+1]]++;
		update(a,x+1,1);//O(M)
	}
	for(i=0;i<n;i++) printf("%d\n",num[i]);
	return 0;
}
*/

