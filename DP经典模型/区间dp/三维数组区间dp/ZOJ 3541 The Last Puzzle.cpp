#include<cstdio>
#include<cstring>
#include<algorithm>
#define INF 0x3f3f3f3f
using namespace std;

/*
题意:一排按钮，要把所有按钮按下,每移动一单位距离需要一单位时间，给出每个按钮的位置b[i]，
并且每个按钮按下后时间a[i]又会弹起来，输出按下按钮方案.
链接:https://zoj.pintia.cn/problem-sets/91827364500/problems/91827368995
思路:dp[i][j][0]代表从i左端点开始往后按,全部按下的最少移动时间
dp[i][j][0]代表从j右端点开始往前按,全部按下的最少移动时间,若时间为INF则中间会有按钮重新弹起
*/

int dp[210][210][2],path[210][210][2],a[210],b[210],n;

int main(){
    memset(dp,0,sizeof(dp));//最后一次按的按钮表示为dp[i][i][0]或dp[i][i][1],若前面的按钮都不会弹起,则全部都能同时按下,最后一个无需再判断
    while(scanf("%d",&n)!=EOF){
        for(int i=1;i<=n;i++)
            scanf("%d",&a[i]);//按下多长时间后会重新弹起
        for(int i=1;i<=n;i++)
            scanf("%d",&b[i]);//每个按钮所在的位置
        for(int l=1;l<n;l++){
            for(int i=1;i+l<=n;i++){
                int j=i+l;
                /*
                dp[i][j][0]先按下i位置的按钮,后按下i+1位置按钮和j位置按钮移动位置哪个花费的时间更少,就再按下哪个按钮
                b[i+1]-b[i]代表后按下i+1位置的按钮所需要从i位置到i+1位置移动的时间
                之所以记录最少时间,因为为了尽可能让前面按下的按钮再次弹起来的时间之内能尽可能多地按下后面的按钮,若最少的时间
                都在按的期间前面的按钮都会弹起,则较大时间的花费更不可能成立.
                */
                if(dp[i+1][j][0]+b[i+1]-b[i]<dp[i+1][j][1]+b[j]-b[i]){
                    dp[i][j][0]=dp[i+1][j][0]+b[i+1]-b[i];
                    path[i][j][0]=0;//记录先按下i位置按钮后,后按下的按钮为[i+1,j]中得到左端点i+1位置按钮
                }
                else{
                    dp[i][j][0]=dp[i+1][j][1]+b[j]-b[i];
                    path[i][j][0]=1;
                }
                //判断按下i位置按钮后再按后续的按钮时i位置的按钮会不会在此期间再弹起来,若会弹起来,dp[i][j][0]赋值为INF 无意义
                if(a[i]<=dp[i][j][0])
                    dp[i][j][0]=INF;
                if(dp[i][j-1][0]+b[j]-b[i]<dp[i][j-1][1]+b[j]-b[j-1]){
                    dp[i][j][1]=dp[i][j-1][0]+b[j]-b[i];
                    path[i][j][1]=0;
                }
                else{
                    dp[i][j][1]=dp[i][j-1][1]+b[j]-b[j-1];
                    path[i][j][1]=1;
                }
                if(a[j]<=dp[i][j][1])
                    dp[i][j][1]=INF;
            }
        }
        int l,r,tmp;
        /*
        可以发现最终能全部按下的情况第一个按下的按钮一定是1或n,关于这个方案是不是有点特殊化,
        另外此题位置也不一定是按照数轴从左至右递增的,排序也没有什么用,因为影响按按钮顺序的除了距离还有本身它再次弹起来的时间.
        之前讨论过这个原因,如果第一个点从中间开始向两边扩展,,先走到最左端,这样走向最右端的时候会把左端我的路径重复走一遍.
        还不如直接从最左端出发.另外dp实际转移时就是从区间的两端点转移的,这样已经是考虑最大程度选择本身等待弹起时间较长的方案去走了,
        本身就更多地避免了重复路径的移动,如果这个特殊的最优的路径都不行,则其它的路径更不行,其实思路是类比ZOJ 3469.
        */
        if(dp[1][n][0]<INF){
            printf("1");//先按1位置按钮
            l=2,r=n;
            tmp=path[1][n][0];
        }
        else if(dp[1][n][1]<INF){
            printf("%d",n);//先按n位置按钮
            l=1,r=n-1;
            tmp=path[1][n][1];
        }
        else{//若dp[1][n][0]和dp[1][n][1]为INF,则说明在后续按按钮时总会有前面的按钮弹出来,无解
            printf("Mission Impossible\n");
            continue;
        }
        while(l<=r){//l==r是最后一次按下的按钮
            if(!tmp){
                printf(" %d",l);
                //tmp为先按下[l,r]中的l左端点后续的[l+1,r]再按哪一个端点,tmp==0为左端点,tmp==1为右端点
                tmp=path[l][r][0];
                l++;
            }
            else{
                printf(" %d",r);
                tmp=path[l][r][1];
                r--;
            }
        }
        printf("\n");
    }
    return 0;
}

/*
记忆化搜索可以写.
*/
