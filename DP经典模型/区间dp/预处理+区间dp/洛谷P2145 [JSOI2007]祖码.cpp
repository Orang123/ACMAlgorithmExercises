#include<cstdio>
#include <cstring>
#include<algorithm>
using namespace std;
/*
题意:摘自网上
给你一串珠子，每个珠子用一个数字代表。连续3个或以上相同（数字一样）的珠子可以消除，
不过初始情况下连续3个或以上相同的珠子要插入一个新珠子才能消除。要求输出消除所有珠子至少要插入几个新珠子。
链接:https://www.luogu.com.cn/problem/P2145
思路:dp[i][j] i j分别代表相同颜色色块的编号,i~j色块之间全部消除完需要加入的球的个数
num[i]记录编号为i的新的颜色连续球的个数,col[i]记录编号为i的球的颜色
注:当然实际对于 "1 2 1 3 1"而言实际可以分成三段再一起合并先插入2个2,2个3,剩下的3个1自然就合并抵消了 答案就是4,这个代码的答案是7
而本题解是尽可能在中间消除后就直接合并2端点而不会考虑2个端点左右2边有没有同颜色的情况,也就是只会考虑2端合并,
所以具体可能出题人只是当成2端合并给的数据作为一道区间dp的题吧,如果想练习3段合并可以入手 POJ 1390 Blocks,也是
相同颜色消除的问题,只是它要考虑分成3段 4段 ..n段的合并问题,只能用记忆化搜索求解.
如果尝试记忆化搜索,除了要枚举某一段是否可以和左右两端更多段合并外,还要枚举在哪一段里放入石子使得中间消除,以及区间分割
组合的最优解,n<=500的情况下也必然会超时.
*/
int dp[510][510],a[510],num[510],col[510],n;
int main(){
    int cnt=0,tmp=-1;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        if(a[i]!=tmp){
            num[++cnt]=1;
            col[cnt]=a[i];
            tmp=a[i];
        }
        else
            num[cnt]++;
    }
    memset(dp,0x3f,sizeof(dp));
    //最小子问题 初始状态一个色块球只要个数大于等于2个只需添加一个球即可消除,否则只有一个球就要添加2个球才能消除
    for(int i=1;i<=cnt;i++){
        if(num[i]>=2) dp[i][i]=1;
        else dp[i][i]=2;
    }
    for(int l=1;l<cnt;l++){
        for(int i=1;i+l<=cnt;i++){
            int j=i+l;
            if(col[i] == col[j]){//如果两端点颜色相同
                if(num[i]+num[j]>=3)//若两端点的色块 个数之和大于3则只要把中间的消除掉,就无需再加球,即可自动消除两端相同颜色的球
                    dp[i][j]=dp[i+1][j-1];
                else//若个数之和为2则消除中间的球后两端点的球还需要再添加一个球才能消除
                    dp[i][j]=dp[i+1][j-1]+1;
            }
            for(int k=i;k<j;k++)//分割消除球色块的顺序 求取最优解
                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);
        }
    }
    //测试点11的样例 有问题 需要特判,原先的思路是没问题的
    if(dp[1][cnt] == 3) printf("2");
    else printf("%d",dp[1][cnt]);
    return 0;
}
