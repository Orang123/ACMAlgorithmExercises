1.能用DFS做的,基本也都能用BFS做,而且BFS做法，
有时并不需要遍历完全,最先出队满足情况的即是要求解,BFS可能编程复杂度较高,需要建模.

2.能用BFS做的,在题目要求的时间上 可能用DFS无法完成,因为DFS无法保证第一次深度搜索到的就是最优解,
需要遍历完所有情况才能比较求出最优解,而BFS因为队列先进先出的原则(本身就是按照步骤较小的顺序入队列的),
第一次满足的解即就是最优解,效率较高,而且还可以配合优先队列去求解相关最值的问题,就是说dfs理论上也能
做出答案,但是暴力太费时,时间不满足条件.

3.dfs更适合应用于 需要枚举回溯 遍历所有可能的 情况组合时,用dfs代码既简介,配合剪枝效率也不低,对于
图论的dfs一般时间也就O(N),而回溯时还需要dfs()再配合一些计算可能复杂度较高点.

4.dfs bfs只是一种遍历方式,一种深度优先 一种广度层序遍历,分别是栈和队列的关系.如果不要求求解最优解,
两种遍历方式都可以应用.
5.dfs侧重过程化的 分析 理解,在过程化中 顺带计算相关结果,如果和枚举的次序 顺序有关 如全排列,那么
回溯后vis要标记0,进入新的dfs后,之前标记取消的点也可以再次枚举访问.

6.对于只是单方面枚举选用哪几个变量的,并且需要选用的数量小于等于给出的数量时,枚举选用的顺序对结果
就不造成影响,比如第一次选择第一个第二次选择第二个和第一次选择第二个第二次选择第一个,这种枚举是
重复的,那么进入新的dfs后,开始枚举的下标就为上一次下标的下一个.这本质是一个组合问题.
不需要用vis标记是否访问.时间复杂度>O(n*(n+1)/2) n超过500感觉就会超时 大于C[n][m]=n!/(m!*(n-m)!) 大于组合数二项式定理的时间复杂度
对于枚举选择的次序会对结果造成影响时,要严格得标记vis数组,回溯时枚举下一个前要将vis标记取消变为
没有访问,然后每一次dfs枚举下标都是从起始位置0开始的.真本质是一个排列问题时间复杂度>n!(阶乘)   O(n^3) n=100大概1s都会超时 要大于n!

7.对于某些图论问题:dfs 其实只有O(n) n的上限可高达10^4 1s以内不会TLE

8.记忆化搜索其实就是递归式的动态规划,动态规划是一种用空间换时间的暴力算法.
用动态规划的时候不可能在子问题还没有得到最优解的情况下就做出决策，而是必须等待子问题
得到了最优解之后才对当下的情况做出决策，所以往往动态规划都可以用 一个或多个递归式来描述。
而递归dfs却是先做出一个决策，然后在去解决子问题。再利用子问题返回的结果去更新大的问题,依次类推,
直到所有结果都遍历完,这就是递归dfs和动态规划的不同。

9.剪枝和记忆化判重并不是一回事,剪枝对于某种情况的深度遍历 如果已经通过一种计算判定
这个结点开始的深度遍历对于问题的求解没有任何更新时可不去遍历,而记忆化判重是对于之前
已经遍历过的结果不再去重新遍历,而直接返回这个结果去优化时间复杂度.