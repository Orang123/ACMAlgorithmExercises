/*
题意:摘自网上
一个书架宽度为bW，现在n本书，每本书有高度h[i]、宽度w[i]，
现在按顺序一本本去放书，现在有很多架子，在放书的时候可以
选择利用架子换一层去放，或者放在当前一层，但是宽度不能超过bW。
问放完所有书的最低高度。
n<=1000,bW<=1000,h[i]<=100,w[i]<=1000.
链接:https://www.luogu.com.cn/problem/UVA10239
思路:书本只能按顺序放置,并且要么尾随放置在当前层,要么重新放在
新的一层的开头位置.同一层的高度为所有书中高度最高的那个书的高度,
实际较好的情况是尽可能多地使得高度相对较高的书本都放置在同一层,
这样其余层书本的高度的上界就会降低,而较高的书本都放置在同一层,
只需取该层最高的书本高度即可,其余书本并不会拉高其余较低层的高度.

列如:书本高度为1、2、3、40、60,如果当前层的总宽度能放下1、2、3、40,放不下
60,如果只是按照顺序放置,1、2、3、40为一层,60为一层,总体的高度就是40+60=100,
但是如果选择将40单独放置在一层,60紧跟其后,总高度就为3+60=63,这样高度就较小.
或者可以让第i本书单独占满一层,使得后面的高度较高的书本恰好能占满另一层,这样
较高的书本就不会分散开,使得整体层较高的高度只会集中在某一层,而不会分散开.

就是说需要枚举每个书本到底是尾随上一本书放在同一层,还是重新放置在新一层的开始位置.
但是在调整书本放置位置的过程中,对于第i本书放置在第新的一层的开始位置这个状态可能是
会重复出现的,因此需要对这个重叠子问题标记,需要用到时直接返回这个结果.
因此记忆化搜索,dp[i]表示第i~n本书所需的最小高度.
*/
//ac 60ms 记忆化搜索
//dp[i]表示第i~n本书所需的最小高度
//时间复杂度是O(n*n)=10^6,因为dp[i]只会计算一次
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 1100
#define INF 1e32
#define eps 1e-6
using namespace std;

int n;
double bW,h[N],w[N],dp[N];

double dfs(int cur){
    if(dp[cur])
        return dp[cur];
    if(cur == n+1)//结束状态是前n本书都放置完毕的情况
        return 0;
    dp[cur]=INF;
    double maxH=h[cur],sumW=w[cur];//第cur本书是肯定放置在新的一层的开始位置的
    //枚举后续书本是重新放置在新的一层开始位置,还是尾随之前的书本放置在同一层
    //枚举从cur+1本书开始,因为第cur本书已经放置在当前层的开头了
    //枚举上界是n+1,因为需要考虑第n本书放置在当前层尾随其后的情况,
    for(int i=cur+1;i<=n+1;i++){
        //要先枚举第i本书放置在下一层,因为如果先枚举第i本书放置在当前层尾随i-1本书其后的位置,
        //这里的maxH比较时已经是包括了第i本身的高度,如果最高的就是h[i],那么h[i]的高度会重复累加的.
        dp[cur]=min(dp[cur],dfs(i)+maxH);
        sumW+=w[i];
        //浮点数不是精确表示的,因此要作差和eps(10^-6)作比较
        if(sumW-bW>eps)//如果第i本书放置在当前层宽度超过书架宽度上限,则结束,因为第i本身放置在新的一层已经计算过.
            break;
        maxH=max(maxH,h[i]);
    }
    return dp[cur];
}

int main(){
    while(scanf("%d%lf",&n,&bW) && n){
        memset(dp,0,sizeof(dp));
        for(int i=1;i<=n;i++)
            scanf("%lf%lf",&h[i],&w[i]);
        printf("%.4f\n",dfs(1));
    }
    return 0;
}

/*
//一个O(nlog(n))的做法 好像和区间 线段树有关
https://www.docin.com/p-2259984247.html
*/
