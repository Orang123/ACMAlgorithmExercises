/*
题意:摘自网上
一台计算机有5个工作单元，一个任务有n个时钟，
每个时钟都要使用一个工作单元，一个工作单元
只能同时执行一个任务的一部分，现在有10个相同
的任务需要执行。问最少用时。
输入'X'表示工作时刻.
n<20.
链接:https://www.luogu.com.cn/problem/UVA690
思路:预处理出初始的5个工作单元的工作的时钟,用
位运算表示状态.
想要时间最少,就是要最大化利用工作单元的在每个时钟
闲置的时刻布置新的任务,并要求一个时钟只能执行一个任务,
多个任务在每个工作单元上 需要间隔开,可以预处理出新的任务
在原先旧任务在n个时钟上可以有哪些合法的间隔.
暴力回溯 枚举每个新的任务可以取哪些合法的时间间隔,一个剪枝
是当前时刻的任务+上后面未执行任务以最小时间间隔执行如果已经
不能比之前得到的时间更短,则不必搜索下去.

这类问题并不会产生重叠子问题,因为虽然都是计算到了第k个任务,但是
每一次之前老任务的状态都是不同的,这会影响到接下来 新任务的所能取
的间隔时间所以无法直接记录dp[k]时的最优结果,实际计算也是先计算的
之前状态的时间才能得到新的任务构成的新状态的结果,计算的结果是从前
往后计算的,而记忆化搜索那个做法是要先计算 最小的问题,再从最小的问题
回溯返回结果 组成大问题的最优解,是从小到大计算结果的.这也体现了动态规划的无后效性.
实际就是无法先计算小问题,因为小问题和之前的状态相关联,无法独立计算.

*/
//ac 200ms 位运算+dfs回溯
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 25
using namespace std;

int n,a[5],b[N],cnt,ans;
char str[5][N];

int check(int *s,int k){
    for(int i=0;i<5;i++){
        //间隔k,旧任务实际要左移,但是预处理时较小的时钟在较低位,
        //所以右移,不为0,说明旧任务和新任务在第i个工作单元某个时钟有冲突,需要设置更大的间隔
        if(a[i] & s[i]>>k)
            return 0;
    }
    return 1;//说明间隔k 下5个工作单元不会有冲突
}

void dfs(int k,int *s,int sum){
    if(sum+b[0]*(10-k)>ans)//剪枝:如果剩下的任务都已最小间隔 执行,所需的时间不能比之前计算的更优,就返回.
        return;
    if(k == 10){//10个任务都合理布置完
        if(sum<ans)
            ans=sum;
        return;
    }
    int p[5];//临时变量 表示在间隔b[i]下 工作单元的时钟状态
    for(int i=0;i<cnt;i++){
        if(check(s,b[i])){
            for(int j=0;j<5;j++)
                p[j]=s[j]>>b[i] | a[j];//和新的工作单元 按位或,表示新的时钟状态
            dfs(k+1,p,sum+b[i]);//增加的时间是间隔b[i],因为一部分时间 同时刻和老任务一起执行的 只多增加了间隔的部分
        }
    }
}

int main(){
    while(scanf("%d",&n) && n){
        cnt=0;
        memset(a,0,sizeof(a));
        for(int i=0;i<5;i++){
            scanf("%s",str[i]);
            for(int j=0;j<n;j++){
                if(str[i][j] == 'X')
                    a[i]|=1<<j;
            }
        }
        for(int i=1;i<=n;i++){
            if(check(a,i))//间隔i是合法的
                b[cnt++]=i;
        }
        ans=n*10;
        dfs(1,a,n);
        printf("%d\n",ans);
    }
    return 0;
}
