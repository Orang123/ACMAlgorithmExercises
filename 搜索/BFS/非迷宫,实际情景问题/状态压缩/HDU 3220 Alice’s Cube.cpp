/*
//题意摘自网上
题意:输入超立方体的16个点的状态，0表示灯是关着的，1表示灯是开着的，
每一个点都连着3条边，如果一条边上的灯的状态不同，那么可以将这两个状态对调，
问最终变成前8个点是0，后8个点是1最少需要几步，小于等于3的直接输出，大于3的输出more.
注意:题目测试样例T最多可达13000个.
链接:http://acm.hdu.edu.cn/showproblem.php?pid=3220
思路:构建立方体的32条边,状态为16个点的开关用16个1二进制位表示,因此vis标记要开到2^16-1,
bfs时判断每条边的两端点的状态是否不同,当开关状态不同时尝试转换,用1<<(点编号-1) & 当前状态值,
可确定出当前点开关与否,如果两点状态不同 就按位异或取反.
但是此题测试样例很多,而目标状态每次都是"0000000011111111",如果每次从初始状态状态做一次bfs,
时间复杂度可达 T*O(2^16-1)=10^4*6*10^4=6*10^8 1s时限肯定TLE.可以考虑以目标状态只做一次,
bfs扩展状态,求出所有步骤数不超过3的状态,之后对每个样例的初始状态直接 判断预处理的目标
状态val数组是否扩展过该初始状态即可判断出是否能完成转换.
*/
//ac 62ms bfs+状态压缩
#include<cstdio>
#include<queue>
#define N 65536
using namespace std;
//储存立方体的32条邻接边
//每个点链接4条边,4*16=64,每条边贡献两个点,会重复算一次,因此总共有64/2=32条边
int edge[32][2]={{1,2},{1,3},{1,5},{1,9},
                 {2,4},{2,6},{2,10},
                 {3,4},{3,7},{3,11},
                 {4,8},{4,12},
                 {5,6},{5,7},{5,13},
                 {6,8},{6,14},
                 {7,8},{7,15},
                 {8,16},
                 {9,10},{9,11},{9,13},
                 {10,12},{10,14},
                 {11,12},{11,15},
                 {12,16},
                 {13,14},{13,15},
                 {14,16},
                 {15,16}};
//val存放16个点上灯的开关情况,0表示关闭,1表示开,可以用16个二进制位表示
//val[x]=y 表示从目标态0000000011111111(二进制)到达x(10进制)状态最少需要变换的次数.
int val[N];//最大的状态值为2^16-1个状态
struct cube{
    int num,cnt;
};
int calState(int *a){
    int state=0;
    for(int i=1;i<=16;i++){
        if(a[i])
            state |=(1<<i-1);//按位与初始状态值
    }
    return state;
}

void bfs(int x){
    queue <cube>Q;
    cube c,tmp;
    c.num=x,c.cnt=0;
    Q.push(c);
    while(!Q.empty()){
        tmp=c=Q.front();
        Q.pop();
        for(int i=0;i<32;i++){
            tmp=c;
            int p1=tmp.num&(1<<edge[i][0]-1);//取出当前顶点的这一位值
            int p2=tmp.num&(1<<edge[i][1]-1);
            //注意这里p1 p2如果顶点灯开着,如果顶点编号不是1,那么p1 p2不为0,但也不为1
            //不能p1!=p2这样判断,可能两个顶点灯都开着 但实际p1也不等于p2
            if((!p1 && p2) || (p1 && !p2){//如果2顶点状态相反，则按位异或交换
                tmp.num^=(1<<edge[i][0]-1);//转换2个端点的状态,按位异或
                tmp.num^=(1<<edge[i][1]-1);
                if(!val[tmp.num]&&tmp.cnt<3){//某一状态没有扩展过切步数<3时放入队列
                    tmp.cnt++;
                    Q.push(tmp);
                    val[tmp.num]=tmp.cnt;
                }
            }
        }
    }
}

int main(){
    int T,a[17]={-1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1},b[17],state1,state2,cnt=1;
    state1=calState(a);
    bfs(state1);
    scanf("%d",&T);
    while(T--){
        for(int i=1;i<=16;i++)
            scanf("%d",&b[i]);
        state2=calState(b);
        if(state2==state1){//初始态和目标态相同 需要次数为0
            printf("Case #%d: 0\n",cnt);
            cnt++;
            continue;
        }
        if(!val[state2])//若初始态无法在3步之内由目标态到达 则输出more
            printf("Case #%d: more\n",cnt);
        else//否则直接输出 目标态到达初始态需要的最少步骤val[state2]
            printf("Case #%d: %d\n",cnt,val[state2]);
        cnt++;
    }
    return 0;
}
