/*
题意:一个sx*sy的大矩形,有n种小矩形,每种小矩形
长x[i],宽y[i],要你分割成小矩形(只能水平和竖直切割),
每种小矩形都有一个价值val[i],问如何分割能得到最大总价值.
大矩形可以有剩余部分,即:不构成任何一种小矩形.
链接:http://acm.hdu.edu.cn/showproblem.php?pid=3127
思路:因为每种小矩形可以无限制切割,所以二维完全背包,但不同于
一般的二维费用背包,那种转移是两个维度的费用是同时刻转移变化的,
而这个二维有可能是长变化或宽变化,实际当前切割出的小矩形会和之前
的小矩形共用一个长或宽,亦或者长或宽都和之前切割的小矩形不对等,
解决这个不对等的问题就是通过尽可能多地装满背包,初始化所有状态
都是合法状态为0,这样在转移时即使上一个状态的长或宽比这个j-y i-x
要小,这里也能衔接到上一状态.具体有2种切法,分别为横切、竖切,每种
切法对应2种情况.所以总共为4种情况(有图解).而且这个二维完全背包小
矩形枚举的循环要放在最内层,因为实际每个i j长宽限定下 选取每种小
矩形切割的顺序会影响到最优解,因此要放置在最内层.
*/

/*
这题的标程的dp 貌似本身也是有问题的
标程的方法过不了下面这组数据：
1
4 8 26
1 5 1
3 7 10
3 19 500
5 10 1000
答案：2521（用贪心的方法就可以得到）
但是标程算出是2520
感觉标程的dp方法有问题，也可能是我题目理解有歧义。
*/

//ac 171ms 二维完全背包,两个维度不同时刻转移,只从一个维度转移分割
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 11
#define M 1100
using namespace std;

int n,sx,sy,x[N],y[N],val[N],dp[M][M];

int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        memset(dp,0,sizeof(dp));
        scanf("%d%d%d",&n,&sx,&sy);
        for(int i=1;i<=n;i++)
            scanf("%d%d%d",&x[i],&y[i],&val[i]);
        for(int i=0;i<=sx;i++){
            for(int j=0;j<=sy;j++){
                for(int k=1;k<=n;k++){
                    if(i>=x[k] && j>=y[k])//横切
                        dp[i][j]=max(dp[i][j],max(dp[x[k]][j-y[k]]+dp[i-x[k]][j],dp[i][j-y[k]]+dp[i-x[k]][y[k]])+val[k]);
                    if(i>=y[k] && j>=x[k])//竖切
                        dp[i][j]=max(dp[i][j],max(dp[y[k]][j-x[k]]+dp[i-y[k]][j],dp[i][j-x[k]]+dp[i-y[k]][x[k]])+val[k]);
                }
            }
        }
        printf("%d\n",dp[sx][sy]);
    }
    return 0;
}

/*
其实只有10种小矩形可供切割,暴力或许效率也不会低,
但是不太好模拟这个切割 长宽变化的过程,对于切割有
剩余 不够的情况不好描述.以及不断拼凑每种小矩形还和
摆放的方式有关,不好做.
*/
