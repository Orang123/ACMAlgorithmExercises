/*
题意:给出初始资金,还有年数,然后给出每个债券的购买价格与
每年获得的利息,每个债券的价格都是1000的倍数,要求在给出的
年份后所能得到的最大本利之和.
列如:现在有两种债券(4000,400)(3000,250) 价钱分别是4000、3000,利息是400、250.
如果你有10000块钱,想买债券但要求收益最大:
第一年:本金:10000，最大收益:900 (3000+3000+4000)
第二年:本金:10900；最大收益:900 (3000+3000+4000)
第三年:本金:11800：最大收益:1050 (4000+4000+3000)
第四年:本金:12850：最大收益:1200 (4000+4000+4000)
所以4年后的本金为14050
注意:最多有10种债券,而初始本金最多可达10^6,增长年限最多40年.
链接:http://acm.hdu.edu.cn/showproblem.php?pid=1963
思路:每种债券可以购买多个显然是完全背包问题.债券的价钱和利息分别
对应物品的体积和价值.因为买完债券后每年会不断产生利息,在这期间可以
将一些年产利息较低的债券卖掉,用卖掉的钱加上之前产生的利息去买年产利息
更高的债券,这个过程其实可以理解为每年产生利息后初始本金都会增加,然后
再重新用增加后的本金进行一遍完全背包,每年进行一次完全背包,每年产生的利息
累加到本金里.但是这样复杂度可达year*n*v=40*10*10^6=4*10^8,显然会TLE.因为
每个债券价格是1000的倍数,所以可以考虑将每个债券的价格和初始本金缩小1000倍,
这样就可降低复杂度.
*/
//ac 78ms 完全背包
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 15
#define M 1000000//因为不清楚 债券产生的利息具体多大,背包容量要设大点
using namespace std;

int n,w[N],val[N],dp[M],sum,y;

int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        memset(dp,0,sizeof(dp));
        scanf("%d%d",&sum,&y);
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%d%d",&w[i],&val[i]);
            w[i]/=1000;
        }
        int tp;
        for(int k=1;k<=y;k++){
            tp=sum/1000;//对于赚的利息不足1000元的部分 除不尽会丢弃,实际少于1000元的部分也不能买任何一张债券
            //不必再初始化dp,每次dp只会在本金增大的部分 更新最优解
            for(int i=1;i<=n;i++){
                for(int j=w[i];j<=tp;j++)
                    dp[j]=max(dp[j],dp[j-w[i]]+val[i]);
            }
            sum+=dp[tp];//增加的本金
        }
        printf("%d\n",sum);
    }
    return 0;
}
