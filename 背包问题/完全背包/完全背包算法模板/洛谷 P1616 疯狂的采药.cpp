/*
题意:LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。
为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。
医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，
采每一种都需要一些时间，每一种也有它自身的价值,同一种草药可以不限数量的采，
我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，
你应该可以让采到的草药的总价值最大。”如果你是 LiYuxiang，你能完成这个任务吗？

释义:有n种物品和一个容量为n的背包,每种物品都有无限件可用.放入第i种物品的耗费的空间是w[i],
得到的价值是val[i].求解:将哪些物品装入背包,可使这些物品的耗费的空间总和不超过背包容量,且价值总和最大.

说明:使用完全背包的条件并不仅限于某种物品个数无限制,这个条件可以拓展地更为宽泛为:v-num[i]*w[i]<w[i],
也就是将第i种物品全部放入容量为v的背包,背包所剩余的容量比第i种物品的体积小,也就是可以尽可能多地装第i种物品,
装到不能再装为止.它的正确性就在于当使用背包容量升序转移时最多所能装入的第i种物品个数肯定不会超过第i种物品的数量上限.
链接:https://www.luogu.com.cn/problem/P1616
思路:裸的完全背包,背包剩余容量升序的原因:
背包九讲:
01背包中要按照v递减的次序来循环的原因是
让v递减是为了保证第i次循环中的状态F[i,v] 是由状态F[i-1,v-Ci]递推而来。
换句话说,这正是为了保证每件物品只选一次,保证在考虑“选入第i件物品”这件策
略时,依据的是一个绝无已经选入第i件物品的子结果F[i-1,v-Ci].而现在完全背
包的特点恰是每种物品可选无限件,所以在考虑“加选一件第i种物品”这种策略时,
却正需要一个可能已选入第i种物品的子结果F[i,v-i],所以就可以并且必须采用v
递增的顺序循环.
*/

/*
完全背包中一个优化:摘自《背包九讲》
若两件物品i、j满足w[i]<=w[j]且val[i]>=val[j],则将可以将物品j直接去掉,不用考虑.
1.朴素的操作是O(n^2),就是枚举每种物品i,判断其它种类物品j是否满足w[i]<=w[j],但val[i]>=val[j],
则可以将物品j去掉.

2.一种优化预处理是应该是分别按照物品体积、价值升序排序,这个排序是传统基于比较的排序.
用二分查找先找到物品i在物品体积中的次序,在判断物品体积比物品i大的物品j,
在物品价值中的次序是否在物品i价值的前面,如果在,就满足w[i]<=w[j]&&val[i]>=val[j],
即:将体积在i物品次序后的物品集合和价值在i物品次序之前的集合求交集,将交集中的物品j
去掉排序复杂度O(nlog(n)) 二分查找复杂度O(log(n)) 集合求交集O(n+m)(数据预排序过)
因此优化操作的时间复杂度O(nlog(n)).

3.针对背包问题而言:因为背包容量可能本身就需要开出一部分空间,而这个背包
容量的空间消耗一定是在计算机可接受的,可以联想到计数排序这种非比较排序线性时间界,
它是根据物品的实际数值在一个辅助数组中所在的次序,通过数值出现的次数来排序,
是一种用空间换取时间的排序策略.而这个辅助数组的大小就是背包容量,所以对于
背包问题它本身就需要开出这样的一个dp[M]来求解问题,在这个空间消耗下再开出
c[M]数组用来辅助计数排序 所以实际空间消耗是O(2*M)=O(M),所以对于背包问题
需要排序时,在它的空间复杂度已经得不到优化的情况下,尽可能削减其余的时间复杂度,
很显然计数排序时间复杂度为O(n),远远优于其余基于比较的排序算法O(nlog(n)).

具体思路是:首先将费用大于v的物品去掉,然后使用类似计数排序的做
法,计算出费用相同的物品中价值最高的是哪个,可以O(v+n)地完成这个优化.

说明:
任何情况下都可将价值小费用高的j换成物美价廉的i,得到的方案至少不会更差.
对于随机生成的数据,这个方法往往会大大减少物品的件数,从而加快速度.然而
这个并不能改善最坏情况的复杂度,因为有可能特别设计的数据可以一件物品也去不掉.
*/
//ac 292ms 完全背包裸题 一维数组 背包容量j升序做法
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 10010
#define M 10000010
typedef long long ll;
using namespace std;

int n,v,w[N],val[N];
//dp[i][j]代表将前i种物品,每种物品不限制数量,放入容量为j的背包最多能获得的价值
//因为前i种物品状态之和前i-1种物品状态相关,滚动数组优化后是dp[j].
ll dp[M];
int main(){
    memset(dp,0,sizeof(dp));
    scanf("%d%d",&v,&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&w[i],&val[i]);
    //把前i种物品作为dp的第一个阶段,在前i种物品前提下枚举背包剩余容量j进行转移
    /*
    事实上第i种物品可放入1、2、..、V/w[i]个,但具体放入几个物品这还取决于
    在上一状态中的最优值是否能得到更新,所以可以不具体考虑放入几个第i种物品
    可以将做法转化成第i种物品可以持续一直放入多件,具体放入几件取决于跟上一状态
    最优值相比较是否能得到更优解.
    */
    for(int i=1;i<=n;i++){//升序降序都可以
        //背包剩余容量一定要升序,这样才能保证dp[j-w[i]]是在考虑是否放入
        //第i种物品的前i种物品最优解的基础上考虑是否继续放入第i种物品
        //j=w[i]时,dp[j-w[i]]表示背包只放入第i种物品,还未放入其它任何物品.
        //当j>w[i]时,dp[j-w[i]]的最优解表示放入前i种物品的最大价值,这里可能
        //没有放入一件第i种物品,也可能放入1件、2件、...,取决于当前背包容量以及
        //与前一状态前i-1种物品最优解的决策.
        for(int j=w[i];j<=v;j++)//完全背包j升序 01背包这里j必须降序
            dp[j]=max(dp[j],dp[j-w[i]]+val[i]);
    }
    /*
    //把枚举背包剩余容量j,必须升序作为dp的第一个阶段,容量为j的前提下枚举放入第i种物品(物品i升序降序都可)
    //事实上因为每种物品放入背包中的数目并没有上限,
    //也可以考虑将背包剩余容量j作为dp枚举的第一个阶段,
    //即在背包剩余容量j下尝试将每种物品都放入背包求解最大价值,
    //在j不断增加,这个dp[j-w[i]]+val[i]的转移就可以表示把第i种
    //物品考虑再重复放入背包是否能获得更大价值,而在前i-1个物品
    //在背包容量j-w[i]时即:dp[j-w[i]]可能放入了1~n中的每一个物品,
    //也可能某些物品并没有放入,而且每种物品的个数也可能放入了多件,
    //这么做的合理性就是因为问题并没有限制每种物品放入数量,所以即使
    //颠倒物品编号i和背包剩余容量j的for循环顺序最优解仍然能得到保证.
    //《背包九讲》中说到这个调到顺序的做法有时可能带来算法时间常数上的优化.
    //ac 361ms 背包剩余容量和物品编号循环颠倒仍然是可行的
    for(int j=0;j<=v;j++){//j必须升序,同一种物品才能放入多件累加价值
        for(int i=1;i<=n;i++)//升序降序都可 i=n;i>=1;i--
        //dp[j-w[i]]可能已经放入了1~n的多种物品,每种物品数量也可能不止1个
            if(j>=w[i])
                dp[j]=max(dp[j],dp[j-w[i]]+val[i]);
    }
    */
    printf("%lld",dp[v]);
    return 0;
}

/*
//二维数组背包容量j升序实现完全背包空间开小了点,原题用二维数组dp会MLE
//O(nv)
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 1010
#define M 1010
using namespace std;

int n,v,w[N],val[N],dp[N][M];

int main(){
    memset(dp,0,sizeof(dp));
    scanf("%d%d",&v,&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&w[i],&val[i]);
    //前i种物品作为dp的第一个阶段,可升序,最优解是dp[n][v],可降序,最优解都是dp[1][v]
    for(int i=1;i<=n;i++){
        for(int j=0;j<=v;j++){
            if(j>=w[i])//这里是在前i种物品最优解基础上考虑累加 第i种物品 即:dp[i][j-w[i]]+val[i]
                //dp[i-1][j]代表第i种物品一个也不选,dp[i][j-w[i]]+val[i]代表第i种物品至少选一个
                dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+val[i]);
            else
                dp[i][j]=dp[i-1][j];
        }
    }
    //背包剩余容量升序作为dp第一个阶段,物品编号升序,最优解dp[n][v]
    //for(int j=0;j<=v;j++){
        //for(int i=1;i<=n;i++){
            //if(j>=w[i])
                //dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+val[i]);
            //else
                //dp[i][j]=dp[i-1][j];
        //}
    //}
    //背包剩余容量升序作为dp第一个阶段,物品编号降序,最优解dp[1][v]
    //for(int j=0;j<=v;j++){
        //for(int i=n;i>=1;i--){
            //if(j>=w[i])
                //dp[i][j]=max(dp[i+1][j],dp[i][j-w[i]]+val[i]);
            //else
                //dp[i][j]=dp[i+1][j];
        //}
    //}
    printf("%d",dp[n][v]);
    return 0;
}
*/

/*
//完全背包转化成01背包问题 ac 100分 1.15s 二进制优化
//基本思想:考虑到第i种物品最多选⌊V/w[i]⌋件,于是可以把
//第i种物品转化为(V/w[i])件费用及价值均不变的物品,然后求解这个01背包问题.
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 10010
#define M 10000010
typedef long long ll;
using namespace std;

int n,v,w[N],val[N];
ll dp[M];

int main(){
    memset(dp,0,sizeof(dp));
    scanf("%d%d",&v,&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&w[i],&val[i]);
    ll tw,tv;//二进制优化 tw tv 左移可能会溢出,因此取long long
    //ac 二进制优化 1.15s 100分 时间复杂度O(n*∑log(v/w[i])*v)
    //把第i种物品拆成费用为w[i]*2^k、价值为val[i]*2^k的若干件物品,
    //其中k取遍满足w[i]*2^k<=V的非负整数.这是二进制的思想.因为,
    //不管最优策略选几件第i种物品,其件数写成二进制后,总可以表示成
    //若干个2^k件物品的和.这样一来就把每种物品拆成O(log(v/w[i]))件物品,是一个很大的改进.
    //如7(111)是由1(001)、2(010)、4(100)累加组合而成,6(110)可由2(010) 4(100)组合而成.3(011)由2(010)和1(001)组合而成
    //时间复杂度O(n*∑log(v/w[i])*v)
    for(int i=1;i<=n;i++){
        //2进制优化这里必须是二进制物品组合在第二层循环,背包容量在第三层循环
        //只有这样才能保证后面的第i种物品组合是在前面第i种物品组合基础上叠加
        //才能保证第i种物品的个数能放置到背包容量上限
        //如果颠倒顺序 物品组合在第三层、背包容量在第二层,会导致dp[j-tw]永远代表前i-1种物品放置的最优解
        //第i种物品最多也只能放置二进制左移的上限这个上限可能是比实际最多能放置第i种物品个数要少的
        for(tw=w[i],tv=val[i];tw<=v;tw<<=1,tv<<=1){//第i种物品 拆分成log(v/w[i])件物品 O(log(v/w[i]))
            for(int j=v;j>=tw;j--)
                dp[j]=max(dp[j],dp[j-tw]+tv);
        }
    }

    //这种二进制优化 背包容量在第2层和物品数量在第三层,顺序颠倒做法是错的
    //如果颠倒顺序 物品组合在第三层、背包容量在第二层,会导致dp[j-tw]永远代表前i-1种物品放置的最优解
    //第i种物品最多也只能放置二进制左移的上限如果比最大容量小,这个上限可能是比实际最多能放置第i种物品个数要少的
    //因为二进制优化要在每种物品组合基础在累加其它第i种物品数目更多的组合,而这个做法无法累加叠加.
    //for(int i=1;i<=n;i++){
        //for(int j=v;j>=w[i];j--){
            //for(tw=w[i],tv=val[i];tw<=j;tw<<=1,tv<<=1){//第i种物品 拆分成log(v/w[i])件物品 O(log(v/w[i]))
                //dp[j]=max(dp[j],dp[j-tw]+tv);
            //}
        //}
    //}

    //TLE 朴素01背包 80分 时间复杂度O(n*∑(v/w[i])*v) 实际物品个数、和背包容量顺序是可以颠倒的
    //从每种物品的角度考虑,与它相关的策略已并非取或不取两种,
    //而是有取0件、取1件、取2件……直至取⌊V/w[i]⌋件等很多种.
    //那就可以枚举出每种物品取的件数的所有可能,将每种可能当成
    //一个单独的物品,将这些所有可能物品放入容量为v的背包,这个问题就变成裸的01背包问题.
    //dp[i][v]表示前i种物品不限制每种物品数量放入一个容量为v的背包
    //能获得的最大价值.可以按照每种物品不同的策略写出状态转移方程,像这样:
    //dp[i][v]= max(dp[i-1][v],dp[i-1][v-k*w[i]]+k*val[i]),k*w[i]<=v.
    //dp[i][v]对于第i种物品需要枚举(v/w[i])件物品单独作为一个物品做01背包
    //滚动数组优化后:dp[v]=max(dp[v],dp[v-k*w[i]]+k*val[i]).
    //时间复杂度O(n*∑(v/w[i])*v)
    //for(int i=1;i<=n;i++){
        //for(tw=w[i],tv=val[i];tw<=v;tw+=w[i],tv+=val[i]){//O(v/w[i])
            //for(int j=v;j>=tw;j--)
                //dp[j]=max(dp[j],dp[j-tw]+tv);
        //}
    //}

    //
    //朴素01背包 实际物品个数、和背包容量顺序是可以颠倒的
    //就算颠倒虽然dp[j-tw]代表前i-1种物品放置的最优解但是第i种物品个数总是能枚举到所能放置的背包容量上界的
    //满足完全背包每种物品在背包容量上限无线放置的要求
    //for(int i=1;i<=n;i++){
        //for(int j=v;j>=w[i];j--){
            //注意这里tw上界是j,当当前背包容量比这个数量的第i种物品 体积小时就退出,后面物品数量是增加的,体积更大
            //for(tw=w[i],tv=val[i];tw<=j;tw+=w[i],tv+=val[i])//O(v/w[i])
                //dp[j]=max(dp[j],dp[j-tw]+tv);
        //}
    //}
    printf("%lld",dp[v]);
    return 0;
}
*/

/*
//TLE 50分 完全背包对应的暴力枚举搜索dfs+剪枝
//不加dp[curV]剪枝只有40分,第5个测试点会tle,加上剪枝 第5个测试点913ms飘过
//时间复杂度O(n^(v/min(w[1..n]))) 十分爆炸
//这个做法不能处理统计恰好装满的方案数,相同的方案会重复计算
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 10010
#define M 10000010
typedef long long ll;
using namespace std;

int n,v,w[N],val[N];
//dp[i]=j 代表当前所选物品所用体积为i时所获得的最大价值是j
ll ans,dp[M];

//复杂度O(n^(v/min(w[1..n])))
void dfs(int curV,int sum){
    if(curV>v)
        return;
    //剪枝 当前所选物品所用体积为curV获得的价值sum并不比之前记录的 体积为curV时的价值更优 不再进行搜索
    if(sum<=dp[curV])
        return;
    dp[curV]=sum;//记录最优值
    if(ans<sum)
        ans=sum;
    //每次取物品都可以取n种中的任何一种
    for(int i=1;i<=n;i++)
        dfs(curV+w[i],sum+val[i]);
}

int main(){
    ans=0;
    scanf("%d%d",&v,&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&w[i],&val[i]);
    dp[0]=-1;//初始时 一个物品也不放 为了避免退出物品,dp[0]设置为-1
    dfs(0,0);
    printf("%d",ans);
    return 0;
}
*/

/*
//TLE 40分 bfs广搜暴力枚举状态进行转移 第5个测试点tle
//不加if(tp.a+a[i]>dp[tp.b+b[i]]) 剪枝会MLE,枚举的状态点太多压入队列,自然也是tle
//每个状态都有n种可能的转移,最坏情况下,每个物品体积为1,最坏时间复杂度 感觉也不是个多项式时间
//bfs这个做法的想法已经非常接近动态规划的思维了,它相比与dfs深度搜索对于所有初始状态的方案并不
//会将某一个方案先行搜索到底,而是所有状态并驱同时刻递进,在每个不同的阶段都会有不优的状态方案
//被剪枝不继续扩展下去,因此bfs的平均效率要远高于dfs,如果dfs第一次搜索玩的方案是最优的,那么dfs
//的效率也会非常高,但是这是最极端最好的情况,平均情况dfs早期搜索到的并不会是最优的方案.
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define N 10010
#define M 10000010
using namespace std;
//dp[i]=j,代表当前所选物品体积为i时所获得的最大价值为j.
int n,v,w[N],val[N],dp[M],ans;

struct State{
    int w,val;
    State(int w=0,int val=0):w(w),val(val){}
};

//每个状态都有n种可能的转移,最坏情况下,每个物品体积为1,最坏时间复杂度 感觉也不是个多项式时间
void bfs(){
    queue<State> Q;
    Q.push(State(0,0));
    State tp;
    while(!Q.empty()){
        tp=Q.front();
        Q.pop();
        if(ans<tp.val)
            ans=tp.val;
        for(int i=1;i<=n;i++){
            //体积超过背包容量m 也不必入队
            if(tp.w+w[i]>v) continue;
            //剪枝 如果当前状态下tp所选物品占体积为tp.b+b[i]所能获得的价值比之前记录的dp[tp.b+b[i]]最优值还小就不必入队.
            if(tp.val+val[i]>dp[tp.w+w[i]]){
                dp[tp.w+w[i]]=tp.val+val[i];
                Q.push(State(tp.w+w[i],tp.val+val[i]));
            }
        }
    }
}

int main(){
    memset(dp,0,sizeof(dp));
    ans=0;
    scanf("%d%d",&v,&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&w[i],&val[i]);
    bfs();
    printf("%d",ans);
    return 0;
}
*/

/*
将完全背包转化为有限个物品(可采用二进制优化),采用01背包对应的暴力枚举搜索
复杂度O(2^n) n是完全背包转为成的优先个物品的个数,当n>22时 基本会tle 2^22=4194304
*/

/*
转化为有限个物品(可采用二进制优化)也有其二进制枚举子集的做法
*/

/*
转化为有限个物品(可采用二进制优化)也可尝试01背包对应的记忆化搜索
即:完全背包->多重背包-(二进制拆分)->01背包->记忆化搜索01背包
*/
