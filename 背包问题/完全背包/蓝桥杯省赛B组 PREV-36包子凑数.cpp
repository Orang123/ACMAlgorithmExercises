/*
题意:小明几乎每天早晨都会在一家包子铺吃早餐.他发现这家包子铺有N种蒸笼,
其中第i种蒸笼恰好能放Ai个包子.每种蒸笼都有非常多笼,可以认为是无限笼.
每当有顾客想买X个包子,卖包子的大叔就会迅速选出若干笼包子来,使得这若干
笼中恰好一共有X个包子.比如一共有3种蒸笼,分别能放3、4和5个包子.当顾客
想买11个包子时,大叔就会选2笼3个的再加1笼5个的(也可能选出1笼3个的再加2笼4个的).
当然有时包子大叔无论如何也凑不出顾客想买的数量.比如一共有3种蒸笼,分别
能放4、5和6个包子.而顾客想买7个包子时,大叔就凑不出来了.小明想知道一共
有多少种数目是包子大叔凑不出来的.

样例:
样例1:n=2,a={4,5}
样例2:n=2,a={4,6}
对于样例1,凑不出的数目包括:1,2,3,6,7,11.
对于样例2,所有奇数都凑不出来,所以有无限多个.
链接:
思路:一个重要定理:如果所有数的最大公约数不为1,则他们无法组成的数有无穷个:
反之,则有有限个.因此先判断是否所有蒸笼装包子数的最大公因数是否为1,如果不为1,
则有无穷个,否则就完全背包 转移状态,最后判断哪些状态点没遍历到.

这里最大可能出现的数要判断到哪:有个想法摘自博客:https://blog.csdn.net/belous_zxy/article/details/84328924
猜测下最大可能出现的数，可用的包子数越少（最少2）；包子数越大（99、100），99x+100y得到一个数，
那么为了能达到每隔1个数都能凑出，势必要用到100-99=1。少用一个100，换用99可以让当前凑出的数-1。
很神奇，那么从一个100开始，99两个100，198三个297。。。
什么时候凑出来xxx01呢，当然是9901。
据此推测可能的最大数是9802，最后一个凑不出来的就是9801。
因此判断的上界设置成10000即可.
*/
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define N 110
#define M 10010
using namespace std;

int n,a[N],dp[M],cnt;

int gcd(int x,int y){
    return !y?x:gcd(y,x%y);
}

int main(){
    cnt=0;
    memset(dp,0,sizeof(dp));
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    int tp=a[1];
    for(int i=2;i<=n;i++)
        tp=gcd(tp,a[i]);
    if(tp!=1){
        printf("INF");
        return 0;
    }
    dp[0]=1;
    for(int i=1;i<=n;i++){
        for(int j=a[i];j<M;j++)
            if(dp[j-a[i]])
                dp[j]=1;
    }
    for(int i=1;i<M;i++){
        if(!dp[i])
            cnt++;
    }
    printf("%d\n",cnt);
    return 0;
}
