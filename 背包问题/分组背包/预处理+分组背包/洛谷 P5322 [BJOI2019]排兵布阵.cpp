/*
题意:小C正在玩一款排兵布阵的游戏.在游戏中有n座城堡,每局对战由两名玩家来争夺这些城堡.
每名玩家有m名士兵,可以向第i座城堡派遣w[i]名士兵去争夺这个城堡,使得总士兵数不超过m.
如果一名玩家向第i座城堡派遣的士兵数严格大于对手派遣士兵数的两倍,那么这名玩家就占领
了这座城堡,获得i分.现在小C即将和其他s名玩家两两对战,这s场对决的派遣士兵方案必须相同.
小C通过某些途径得知了其他s名玩家即将使用的策略,他想知道他应该使用什么策略来最大化自
己的总分.由于方案可能不唯一,你只需要输出小C总分的最大值.
链接:https://www.luogu.com.cn/problem/P5322
思路:分组背包,可以将总士兵数m看做背包容量,可以按城堡分组,每个城堡组i中对应的物品为
其它玩家分配给该城堡的士兵数.可以将每个城堡i对应的所有玩家分配的士兵数贪心排序,这样
只要小c分配的士兵数大于第k个玩家分配士兵数的两倍时,小c就可获得k*i分数,因为第1个、第
2个、...、第k-1个玩家都比第k个玩家分配的士兵数少.实际状态转移时 对于第k个玩家分配的
士兵数,小c是贪心分配2*w[i][k]+1刚好赢得第k个玩家即可,这样才能将其余士兵分配在别的城堡,
得分才能最大化.
*/
//ac 777ms 预处理+贪心分组背包
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 110
#define M 20010
using namespace std;

//w[i][j]代表第i个城堡中第j个玩家分配的士兵数
//dp[i][j]前i个城堡在最大可分配j个士兵时最大可获得的分数
int s,n,m,w[N][N],dp[M];

int main(){
    scanf("%d%d%d",&s,&n,&m);
    for(int i=1;i<=s;i++){
        for(int j=1;j<=n;j++)
            //第j个城堡中第i个玩家分配的士兵数为w[j][i]
            scanf("%d",&w[j][i]);
    }
    //将第i个城堡各个玩家分配的士兵数 从小到大排序
    for(int i=1;i<=n;i++)
        sort(w[i]+1,w[i]+1+s);
    for(int i=1;i<=n;i++){
        for(int j=m;j>=1;j--){//小c要获得第i个城堡的分数 至少要分配一个士兵,因此j的下界是1
            //当前分配的士兵数必须比第k个士兵分配的士兵的2倍还大
            for(int k=1;k<=s && j>w[i][k]*2;k++)
                //这里是按照要赢得第k个玩家,最少要分配的士兵数为2*w[i][k]+1来算的
                //贪心:只有尽可能少的分配士兵数才能使得其它士兵能分配到别的城堡中,得分才能最大化
                //因此上一状态是dp[i-1][j-2*w[i][k]-1]
                dp[j]=max(dp[j],dp[j-2*w[i][k]-1]+k*i);
        }
    }
    printf("%d",dp[m]);
}
