#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 55
#define M 2600
using namespace std;
//ac 140ms 01背包 尽可能多地装满背包
/*
题意:给了n张卡片,然后每个卡片有一个等级l[i],有一个伤害d[i],有两种操作:
第一种操作是将第一张牌移到最后一张,第二种操作是将第一张牌打出,造成
d[i]伤害,然后之后的l[i]张牌(包括要打出的第一张牌)移除出去,如果剩余的牌数
不够l[i],这第一张牌是不能够打出的,现在问n张排最大的能造成的伤害是多少.
1<=n<=50,1<=li<=50,1<=di<=10000.
链接:https://community.topcoder.com/stat?c=problem_statement&pm=12329
https://vjudge.net/problem/TopCoder-12329
思路:首先操作1将第1张牌放置在最后的位置,如果这个过程不打出任何一张牌,
实际如果将牌看成环状的,那么它们之间的实际顺序并没有变化,只有在移动的
过程中不断打出排,原本的位置顺序才会发生变化,而打牌打出尽可能多伤害可以
看成是将n张牌装进容量为n的背包最多获得的价值,物品容积为l[i],物品价值为d[i],
之所以容积是l[i]是因为,实际打出第一张牌会将其后的(l[i]-1)张牌也移除而并不会
造成额外的伤害,而实际牌之间的先后顺序可以通过不断地打出排和移动来调整,这对问题
本身并没有什么影响.尽可能多地装满背包,可能会有n很大,而排l[i]很大的情况,n并未
装满的情况.
*/
int dp[M];
class SpellCards{
public:
    int maxDamage(vector<int>li, vector<int>di){
        int n=li.size();
        for(int i=0;i<n;i++){
            for(int j=n;j>=li[i];j--){
                dp[j]=max(dp[j],dp[j-li[i]]+di[i]);
            }
        }
        return dp[n];
    }
};

/*
例子
0）

{1,1,1}
{10,20,30}
返回：60
您可以连续三次玩纸牌0，造成10 + 20 + 30 = 60伤害。
1）

{3,3,3}
{10,20,30}
回报：30
在这里，最好通过将最后一张卡移动到该行的开头开始。在第二个回合中，我们使用这张卡造成30点伤害。之后，所有三张卡都将被丢弃。
2）

{4,4,4}
{10,20,30}
返回值：0
这次您不能使用任何咒语卡。
3）

{50,1,50,1,50}
{10,20,30,40,50}
返回：60
您可以使用2张伤害为20和40的卡。
4）

{2,1,1}
{40,40,10}
返回：80
5）

{1,2,1,1,3,2,1}
{10,40,10,10,90,40,10}
回报：170
6）

{1,2,2,3,1,4,2}
{113,253,523,941,250,534,454}
返回：1918
*/
