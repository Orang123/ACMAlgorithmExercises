#include<cstdio>
#include<cstring>
#include<stack>
#include<algorithm>
#define N 100
#define M 5500
using namespace std;

/*
并查集和tarjan关系:
tarjan和并查集不同,并查集它着重体现集合相并性,并没有构成图的概念,没有严格的方向性,
只要两个集合间有连线关系,即可相并成一个集合,只是判断是否属于一个连通集合里,
不在就并,并查集问题可采用构建无向图构造回边对每个点dfs或tarjan都能解决.
一般能用并查集求解集合(连通)个数,也一定能用tarjan求解scc来做,而且tarjan效率较高,
常见的入floyd传递闭包,tarjan也能做.

有向图相关概念:
1.有向图:由有向边的构成的图.需要注意的是这是Tarjan算法的前提和条件.
2.强连通:如果两个顶点可以相互通达,则称两个顶点强连通.
3.强连通图:如果有向图G的每两个顶点都强连通,称G是一个强连通图(Strongly Connected Graph,SCG).
一个SCG(强连通图)中的所有点的出入度都是不为0的,因此使得DAG成为SCG需要加边的
最小条数就为出度和入度为0的点的最大值.
4.强连通分量:非强连通图有向图的极大强连通子图,称为强连通分量(Strongly Connected Components,SCC).
5.有向无环图(Directed acyclic Graph,DAG):指的是一个无回路的有向图,并不说真的没有环,可以有环,
但是环上不能循环从任意一点遍历到任一点,并不是有向树,从图的形状上是可以有圈的.
有向无环图的生成树个数等于入度非零的节点的入度积.
通过缩点可将有向图转化成DAG(有向无环图),一般有环图都需要转化成无环图才能讨论一些问题的求解,
将原图尽可能多的连通环看成一个点缩点,这样就可以转化成无环图.
6.DFS生成树与强连通分量之间的关系.
如果结点u是某个强连通分量在搜索树中遇到的第一个结点,那么这个强连通分量的其余结点
肯定是在搜索树中以u为根的子树中.u被称为这个强连通分量的根.
这棵DFS生成树上的边称作树边,不在DFS生成树上的边称作非树边.
可以保证所有非树边连接的两个点在DFS生成树上都满足其中一个是另一个的祖先.

注意:
1.自环 重边不会影响tarjan求解scc的结果,要去重边和自环的话,可以考虑用邻接矩阵.

相关结论:
1.DAG中前驱祖先节点最多的点一定是出度为0的点,一般可通过反向建边树形dp求解根节点的儿子个数来解决,
注意要判重,避免重复累加儿子.
*/

struct node{
    int to,next;//to是代表a这个点出发边所连接的结点,next指向下一个a结点连接的结点的下标
}edge[M<<1];//n个点构成的图最多有n*n/2条边 即:每个点都和其余点有连边 实际最大取上n*(n-1)/2=4950就好
int head[N],cnt;//head[i] 编号为i的点所连接点对应的数组下标,cnt表示数组当前指针
int dfn[N];//dfn[i]代表第一次dfs到i点的次序
int low[N];//low[i]代表i点可以回到的最早次序
int num;//遍历的次序从 1开始
//之所以使用栈,是因为tarjan采取深度优先分离SCC,这样才能依据回溯 分离出此前遍历过点构成一个SCC,这样do while的判断条件也能正常结束
stack<int> s;//根据dfs遍历结点的先后顺序入栈,越靠后入的,越早出栈
bool in[N];//用来表明访问过的元素是否还在栈中,避免已分离出的点的low[i]对还在原图中的点low[j]造成影响
int block[N],id;//block[i]=id 代表编号为i的点属于编号为id的强连通分量

void addEdge(int from,int to){
    edge[cnt].to=to;
    edge[cnt].next=head[from];
    head[from]=cnt++;
}
//时间复杂度 O(V+E) 点数+边数 dfs O(E) 划分强连通分量 stack O(V)
void dfs(int u){
    dfn[u]=low[u]=++num;//初始化dfn、low都为访问的次序
    s.push(u);
    //u结点已入栈 这个in数组实际可以不设置,直接通过!block[v] 若block[v]==0则说明v点还在栈中没被分离,否则v点已经被分离成单独的scc了,需要初始化block为0
    in[u]=true;
    int v;
    for(int i=head[u];i!=-1;i=edge[i].next){//枚举u结点连接的每一个结点进行深度遍历
        v=edge[i].to;
        /*  v未被访问：继续对v进行深度搜索。在回溯过程中，用low[v]更新low[u]。
            因为存在从u到v的直接路径，所以v能够回溯到的已经在栈中的结点,u也一定能够回溯到。
            v被访问过，已经在栈中：即已经被访问过，根据low值的定义（能够回溯到的最早的已经在栈中的结点），则用dfn[v]更新low[u]。
            v被访问过，已不在在栈中：说明v已搜索完毕，其所在连通分量已被处理，所以不用对其做操作。*/
        if(!dfn[v]){//如果点i没有被访问过
            dfs(v);//深度优先遍历v点
            low[u]=min(low[u],low[v]);//遍历完 v点回溯时,更新low取u和v之间的最小值，值越小代表最后分离的强连通分量越大,表示如果v能回到更早访问的结点m,因为u与v连接，那么u也能回到更早的结点m 即传递性
        }
        /*in[v]这个判断条件很重要，这样可以避免已经确定在其他联通图的v,因为u到v的单向边而影响到u的low
          也就是已经确定了的联通图要剔除掉，剔除的办法就是判断其还在栈中，因为已经确定了的连通图的点
	      in在下面的do while中已经设为false了(即已经从栈中剔除了)*/
        //否则如果已经访问过了,如果还在栈中,还未分离出去成独立的强连通子图,如果不采取in[v]判断而根据dfn[v]判断,
        //会导致本该独立的点无法出栈不满足出栈的条件dfn[u]!=low[u],最小的low比最小的dfn还小,
        //因为low[u]=dfn[v]<dfn[u],{2,3,6,7},都无法出栈.
        else if(in[v])//有可能 dfn[v]大于low[u],除非是回边,v是先遍历的点的时候dfn[v]才小于low[u]
            //对于求解强连通分量 low[u]=min(low[u],low[v]) 这种写法也是可以的.但是点双连通不行.
            low[u]=min(low[u],dfn[v]);//如果dfn[v]对应的访问次序更小,代表u这个点就能回到更早访问的点,所能求取的强连通分量也就越大
    }
    //不能拿low值相等来判是否在一个SCC里,对于SCC中含多个环的情况会出错
    if(dfn[u] == low[u]){//dfn[u]==low[u]，就可以把这个节点之后的节点全部弹栈，构成连通图u这个点为强连通分量的根节点
        ++id;//新的强连通分量编号 id++ 也代表当前已求出的强连通子图的数量
        do{
            v=s.top();//在访问u之后访问的结点包括u(根节点)依次出栈构成连通子图
            in[v]=false;//v不在栈中了
            block[v]=id;//v这个点所对应的强连通分量的编号 也就是对结点染色
            s.pop();
        }while(v != u);
    }
}

int main(){
    int n,m,a,b;
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);//n个点 m条边
    while(m--){
        scanf("%d %d",&a,&b);
        addEdge(a,b);
    }
    for(int i=1;i<=n;i++){//因为给出的图并不一定是强连通图,得对每个点都尝试 分离,列如先遍历 1这个点 也只会分理出{1,4,5}为第一个强连通分量 还剩下{2,3,6}、{7}这两个强连通分量
        if(!dfn[i])
            dfs(i);
    }
    //dfs(2) 遍历2这个点一次性就可以将3个强连通分量分离出来
    for(int i=1;i<=n;i++){
        printf("dfn[%d]=%d low[%d]=%d block[%d]=%d\n",i,dfn[i],i,low[i],i,block[i]);
    }
    return 0;
}
/*
7 9
2 3
3 6
6 2
6 7
3 1
1 4
4 5
5 4
5 1
*/
