#include<cstdio>
#include<cstring>
#include<stack>
#include<algorithm>
#define N 100
#define M 10000//M=N*(N-1)
using namespace std;
struct node{
    int to,next,use;
}edge[M];
int head[N],cnt;
int outde[N],inde[N];
stack<int> s;

void addEdge(int from,int to){
    edge[cnt].to=to;
    edge[cnt].next=head[from];
    head[from]=cnt++;
}

/*相关概念:

欧拉通路:一条经过图上所有边的路径
欧拉回路:一条经过图上所有边的回路(环)

对于无向图而言相关性质:
1.无向图中不存在奇点时,该图必定存在欧拉回路。(对于每个点一进一出是对应的)
2.无向图中存在奇点且只存在2个奇点时,该图必定存在欧拉通路。(对于起点只能出去不会回来,对于终点只可进去不可出去)
3.无向图中奇点的个数永远是偶数,不可能是奇数。
原因:对于无向图,每条边对2个端点贡献2个度,因此假设无向图有n条边,则所有结点的度数之和为2n(偶数)
若无向图中存在奇数个奇点 则所有结点的度数之和为  奇数个奇点度之和(奇数)+偶点度之和(偶数)=奇数,与性质3相违背,得证.

对于有向图而言相关性质:
1.有向图连通,每个点的出度和入度相等。(一个进去刚好对应一个出去)
2.有向图连通,有且仅由2个点出度与入度不相等,且2个点入度只差与出度只差都为1.
通路的起点为出度多1的点终点为读入多1的点。(即点的入度与出度之和为偶数+1=奇数)
*/

/*
dfs前提是ans=0或2,即可确定有欧拉路径或欧拉回路,dfs搜索入栈
才有意义,建立在有欧拉路的基础上去搜索,会发现这个搜索会一路
搜索到底,刚好把所有的边都遍历完(有相关的证明,知道结果就好,无需理会),等到回溯时其它边也全部在儿子结点的dfs
中被遍历完成,只进行入栈的操作,根据栈后进先出,栈顶的元素时第一次遍历的起点。
若原图中本身没有欧拉路径,那么我们在回溯时若发现还有边未遍历再去dfs,这样的回溯
实际违背了欧拉路对每条边不会重复遍历的定义,问题是我们在回溯的时候在去遍历了别的
边,导致回溯的过程是不是变成了边重复遍历的过程,虽然结果是把所有的边都遍历了,但显然不符合
一笔画成图的定义了。
*/
//Hierholzer 算法时间复杂度 O(E+V) dfs for循环为O(E) 点入栈为O(V)为所有的点,因为对于连通图当所有的边被访问时,所有的点也同时被访问了
void dfs(int u){
    int v;
    for(int i=head[u];i!=-1;i=edge[i].next){//O(E)
        if(!edge[i].use){//若该边之前没有遍历则可继续遍历
            v=edge[i].to;
            edge[i].use=1;//将改变标记已遍历过,欧拉路径&欧拉回路不会重复遍历边
            //edge[i^1].use=1;
            dfs(v);
        }
    }
    s.push(u);//回溯时将当前遍历顺序下的点入栈 实际每个点在一个dfs里只会遍历到一个点 O(V)
}

int main(){
    int n,m,a,b;
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    while(m--){
        scanf("%d%d",&a,&b);
        addEdge(a,b);//构造有向图
        //addEdge(b,a);
        outde[a]++;//a点出度+1
        inde[b]++;//b点入度+1
    }
    int ans=0,S=1;
    for(int i=1;i<=n;i++){//计算奇点的个数
        if(inde[i]!=outde[i]){//这里也可以判断(inde[i]+outde[i])&1是否为奇数
            ans++;
            if(outde[i] == inde[i]+1)//若是奇点 且出度比入度大1,则该点为遍历的起点
                S=i;
        }
    }
    /*欧拉路径&欧拉回路的dfs是建立在它有欧拉路径的前提下的,
      若计算出奇点个数大于2则没有欧拉路径和欧拉回路
    */
    if(ans>2){
        printf("该图没有欧拉路径和欧拉回路\n");
        return 0;
    }
    dfs(S);
    int v;
    while(!s.empty()){
        v=s.top();
        s.pop();
        printf("%d ",v);
    }
    return 0;
}

/*
5 9
1 2
2 3
2 4
1 4
3 1
3 5
4 3
4 5
5 2
*/
