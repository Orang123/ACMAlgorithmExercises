关于KM算法现在有5种写法
1.最小差值d的计算放在匈牙利算法外面,即KM() while(1)里 for两层循环计算. O(V^4)
2.最小差值d的求取放在匈牙利算法内部,每次while(1)里初始化d=INF. O(V^2*E)
这种做法对于HDU 2426就比较慢,不知为何,也许和输入数据 边权值有关.
3.采用slack数组松弛优化 放在dfs匈牙利算法内部求Y集合每个待加入可行边端点要更新的最小差值, O(V^2*E)
在KM() while(1)里一层循环比较求出所有Y集合中每个点最小差值的最小值作为交错树中访问点要更新的最小差值.
4.bfs版本 O(N^2+N*M)  N和M为两个集合元素个数,也有种严格时间复杂度O(V^3)
5.上述4种算法存图都采用邻接矩阵 因为KM算法的二分图一般X集合中每个点都和Y集合所有点有连边边权,
当X集合中每个点并不是和Y集合每个点都有连边时,可以采用链式前向星存图,效率较高.
以上5种做法,准确来说是前4种做法,第三种做法在大多数时候都是可行的效率能高些,1、2做法有时较慢,
而第4种bfs版本效率是最高的严格的O(V^3),但暂时还未理解.


KM算法几种WA、TLE的改进办法:
1.如果mp对于不存在的边不考虑配对 wa,就换成X集合每个点在都和Y集合中点有连边,最后判断
匹配边集中是否有边是本身不存在的边 初始化可以初始化0 -1 INF等,判断是否等于0 -1 INF 等于就说明不存在边算入了匹配
这个wa的原因可能是mp初始化为-1、-2导致的,可以换成-3、-1、-500、-INF试试应该就好了,尚不知原因,HDU 2426就是这个情况.
2.对于dfs不考虑不存在边 TLE的情况,可根据题意将不存在边权设置为0,这样按照X集合每个点都和Y集合点
有连边,对于实际不存在的连边放入匹配集,因为边权为0,也不会影响结果.HDU 3395就是这种情况.