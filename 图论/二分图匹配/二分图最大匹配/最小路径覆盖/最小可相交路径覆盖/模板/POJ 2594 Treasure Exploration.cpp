#include<cstdio>
#include<cstring>
#define N 510//n<=500 因此可用邻接矩阵存图,方便floyd处理传递闭包
using namespace std;
//ac 1047ms 最小可相交路径覆盖
/*
注意:应用这个定理一定前提是DAG,不能有环也不能是无向图,否则结果会出错.
最小可相交路径覆盖=最不可相交路径覆盖(folyd处理原图传递闭包后)=顶点数-最大匹配
*/

/*
题意:一个有向无环图,现在要在每个点放置机器人,每个点的机器人可以沿着有向边
到达其余点(直到不能走,没有边连接),现在问最少要在点放置多少机器人可保证所有点都被访问.
注意:同一点可被多个机器人访问,但所有路径的经过的边仍然只能由一个机器人走,
即真正机器人访问路径点可重叠相交.
链接:http://poj.org/problem?id=2594
思路:最小可相交路径覆盖,多个机器人可访问同一点.需要先用floyd
传递闭包处理点之间的连通可达性这样就可以避开绕过别的点覆盖路径中
已被标记的点,将问题转化为最小不相交路径覆盖.
eg:1->3,2->3,3->4,3->5 DAG
1   5
 \ /
  3
 / \
2   4
最小不相交路径覆盖为:1->3->4,2,5. 共3条路径.
而它的最小可相交路径覆盖为:1->3->4,2->3->5,但在实际的匈牙利匹配中,
如果先考虑1,那么1->3,link[v]已经被标记,到2时,和2相连的只有3,若将1->3拆散,
1就没有连边了,1找不到增广路,所以2是失配的.
所以就需要floyd将1->3,3->4,处理为1->4,这样1就有1->3,1->4,2条连边,当2->3配对时,
1->4还能配对,再考虑从3点出发,4是和1配对的,1->4拆散后没有增广路,因此3只能和5配对,即:3->5,
而4、5两点是没有连边的,现在总共配对了3条边即:2->3,3->5,1->4
所以最小可相交路径覆盖=最不可相交路径覆盖(folyd处理原图传递闭包后)=顶点数-最大匹配=5-3=2;
即路径为:2->3->5,1->3->4. 2条路径.
*/
int n,m,mp[N][N],vis[N],link[N],ans;

int dfs(int u){
    for(int v=1;v<=n;v++){
        if(!mp[u][v] || vis[v]) continue;
        vis[v]=1;
        if(!link[v] || dfs(link[v])){
            link[v]=u;
            return 1;
        }
    }
    return 0;
}

void init(){
    ans=0;
    memset(mp,0,sizeof(mp));
    memset(link,0,sizeof(link));
}

int main(){
    int u,v;
    while(scanf("%d%d",&n,&m) && n+m){
        init();
        while(m--){
            scanf("%d%d",&u,&v);
            mp[u][v]=1;//n<=500 因此可用邻接矩阵存图,方便floyd处理传递闭包
        }
        //floyd传递闭包处理点之间的连通可达性这样就可以避开绕过别的点覆盖路径中
        //已被标记的点,将问题转化为最小不相交路径覆盖.
        for(int k=1;k<=n;k++){
            for(int i=1;i<=n;i++)//这里可优化if(mp[i][k]) 才进行第三层循环
                for(int j=1;j<=n;j++)
                    mp[i][j]|=(mp[i][k] & mp[k][j]);//如果i能到达k,k能到达j,那么i就能到达j.
        }
        for(int i=1;i<=n;i++){
            memset(vis,0,sizeof(vis));
            if(dfs(i)) ans++;
        }
        printf("%d\n",n-ans);//最小路径覆盖=顶点数-最大匹配.
    }
    return 0;
}
