#include<cstdio>
#include<cstring>
#include<vector>
#define N 510
using namespace std;
/*
二分图匹配参考博客:https://blog.csdn.net/u013384984/article/details/90718287
https://blog.csdn.net/qq_41730082/article/details/81162561
http://www.renfei.org/blog/bipartite-matching.html
相关概念:
1.匹配或是独立边集是一张图中没有公共顶点的边的集合.
2.二分图:设G=(V,E)是一个无向图,如果顶点V可分割为两个互不相交的子集(A,B),
并且图中的每条边(i,j)所关联的两个顶点i和j分别属于这两个不同的顶点集
(i in A,j in B),则称图G为一个二分图.
注意:
(1).二分图不存在长度为奇数的环,因为每一条边都是从一个集合走到另一个集合,只有走偶数次才可能回到同一个集合.
判断回路的奇偶性可以应用dfs/bfs遍历整张图交叉染色,判断回路当前点与已遍历点颜色是否相同,若相同,回路长度
为奇数,若不相同,回路长度为偶数.
(2)无向图转换为二分图需要划分的两个集合可通过交叉染色法来分,若不存在奇环,则颜色为0(黑色)的点可作为一个集合,
颜色为1(白色)的点可作为另一个集合.
(3).若原图中没有环,则必定可以划分出2个集合,必定是二分图,eg:树一定是二分图.
(4).二分图中不能有孤立点,因为二分图是把边的两个端点划分到2个集合中的,而孤立点不在边集中不符合概念.
3.一组两两没有公共点的边集M称为这张图的匹配,其中边数最大的边集M为最大匹配.
最大匹配的方案可能不唯一,但最大匹配的数量是唯一的.
完美匹配:如果一个匹配中,图中的每个顶点都和匹配中某条边相关联,则称此匹配为完全匹配(完美匹配),也称作完备匹配.
如果二分图两集合点数不相等,则不存在完美匹配,因为较大集合中的点必然会有剩余未配对的点.
完备匹配一定是最大匹配,而最大匹配不一定是完备匹配.完美匹配不一定存在.
4.当图中的边带权的时候,边权和最大的为最大权匹配.
5.匹配M中的边称为匹配边,反之称为未匹配边;
一个点如果属于M且为至多一条边的端点,称为匹配点,反之称为未匹配点.
6.一张二分图上的匹配称为二分图匹配.
设G为二分图,若在G的子图M中,任意两条边都没有公共节点,那么称M为二分图G的一个匹配,且M的边数为匹配数.
7.M-饱和点:对于v属于V,如果v与M中的某条边关联,则称v是M-饱和点,否则称v是非M-饱和点.
8.交错路:从一个未匹配点出发,依次经过非匹配边、匹配边、非匹配边…形成的路径叫交错路.
9.增广路:是始于非匹配点且终于非匹配点的交错路,也就是路径的起点和终端不属于原先的匹配构成的交错路.
增广路有一个重要特点:非匹配边比匹配边多一条.因此,研究增广路的意义是改进匹配.
只要把增广路中的匹配边和非匹配边的身份交换即可.交换后,匹配边数目比原来多了1条,依然是交错路.
增广路长度一定为奇数,因为非匹配边和匹配边总是成对出现,但非匹配的边比匹配的边要多一条,即总数2n+1为奇数.

匈牙利算法:时间复杂度:O(VE)
前提条件:原图要能划分成一个二分图才行.
这就是匈牙利算法的流程,其中找妹子是个递归的过程,最关键的字就是“腾”字
其原则大概是:有机会上,没机会创造机会也要上
1.匈牙利算法寻找最大匹配,就是通过不断寻找原有匹配M的增广路径,因为找到一条M匹配的增广路径,就意味着一个更大的匹配M',其恰好比M多一条边.
2.对于图来说,最大匹配不是唯一的,但是最大匹配的大小是唯一的.
这取决于未匹配点抢占的是哪一个已匹配的点,因为匈牙利算法是递归的,所以一般抢占的都是为匹配点连接的第一个点.
3.当图中再没有增广路径了,就意味当前匹配已是最大匹配.

二分图相关性质定理:
边覆盖:若图G的每个顶点都与L中至少一条边关联,则称L是G的边覆盖.
若边覆盖L的任何真子集都不是G的边覆盖,则称L是G的极小边覆盖.
G的含边数最少的边覆盖称为G的最小边覆盖,其所含边的数目称为G的边覆盖数.
通俗地讲 最小边覆盖:实质是个边集,这个集合里的边能覆盖所有的点,最小边覆盖是
满足这个要求的所有边集中边数最少的一个.
1.二分图中最小边覆盖=顶点数-最大匹配数.

注意:
1.二分图匹配中还有一个Hopcroft-Karp(HK)算法,复杂度为O(sqrt(V)*E),
由于复杂度并没有降低多少,代码量十分大,只有HDU 2389卡了HK算法的一个根号时间界.
2.二分图是无向图,但是在解题时一般输入会区分开2个点集,所以通常情况下也只需建一条
X集合中的点指向Y集合中点的有向边即可,链式前向星和邻接表vector、或邻接矩阵都是可以的.
3.算法时间复杂度O(V*E)决定了数据量一般不会超过1000
4.KM算法O(V^2*E)一般数据量不会超过500.
5.二分图不存在长度为奇数的环,因为每一条边都是从一个集合走到另一个集合,只有走偶数次才可能回到同一个集合.
6.增广路长度一定为奇数,因为非匹配边和匹配边总是成对出现,但非匹配的边比匹配的边要多一条,即总数2n+1为奇数.
7.非二分图上求解最大匹配如果应用匈牙利算法,会失去实际意义,因为同一集合内的匹配连边没有实际意义,对于一般图的
最大匹配应该考虑带花树开花算法.
*/

//ac 0ms
/*
题意:m个女生,n个男生去做过山车,但是过山车必须是一个男生和一个女生成对在一起才能乘坐,
现在有k对男女朋友关系,问最多有多少对组合能坐上过山车.
链接:http://acm.hdu.edu.cn/showproblem.php?pid=2063
思路:匈牙利算法求解二分图最大匹配模板题.
*/

vector<int> mp[N];
bool visit[N];
int k,m,n,link[N];//link[v]表示v连向的点(v连的边另一端的匹配点),visit表示男生的集合某个点是否已配对.
bool dfs(int x){
    int v;
    for(int i=0;i<mp[x].size();i++){
        v=mp[x][i];
        if(!visit[v]){//如果男生v还没访问 考虑是否能配对
            visit[v]=true;
            /*
            若是v还没有被配对,就把v配对给x,否则出现冲突时让link[v]腾出v给x;
            那种第一次dfs 就link[v]==-1的,并不是通过增广路(因为其路径长度是1,虽然左右端点都不在匹配集中,
            其实也可单独看做一条增广路吧)来增加匹配数的,本身就能直接找到匹配点,除非本身这个匹配点之前已经被匹配了,
            才是通过搜索增广路来增加的.实际就是长度为1的路径,只不过2端点都不在原匹配中,因为路径中没有匹配边,所以
            不属于交错路.
            */
            //如果男生v还没配对,则将男生v和女生x配对,否则将男生v原先的配对女生link[v](x')拆散,将男生v配对给当前女生x.
            //然后再考虑被拆散的女生x'去搜素还没访问并且未配对的男生v与其配对,依次类推,就是不断拆散腾出位置的过程.
            if(link[v]==-1 || dfs(link[v])){
                link[v]=x;//把v连接到x 这里在回溯时会一次腾出空位,构建新的连接
                return true;//代表成功找到一条比原先匹配数多1的增广路 ans要加1
            }
        }
    }
    return false;//表示这个点未能连边找到新的匹配边,没有构造出新的增广路,匹配数未增加
}

/*
//vis数组时间戳优化版本 避免考虑X集合中每个点的配对时for循环初始化vis数组
//dfs(i,i)
int dfs(int u,int clock){
    for(int i=head[u];i!=-1;i=edge[i].next){
        int v=edge[i].to;
        if(vis[v] == clock) continue;//代表当前点 已经被访问
        vis[v]=clock;//标记访问过点的时间戳为clock
        if(!link[v] || dfs(link[v],clock)){
            link[v]=u;
            return 1;
        }
    }
    return 0;
}
*/

int main(){
    int x,y,ans;
    while(scanf("%d",&k) && k){
        scanf("%d%d",&m,&n);
        ans=0;
        memset(link,-1,sizeof(link));
        for(int i=0;i<N;i++)
            mp[i].clear();
        for(int i=1;i<=k;i++){
            scanf("%d%d",&x,&y);
            mp[x].push_back(y);//只需构造单向图,从一个集合去考虑匹配另一个集合即可,最终结果不受影响
        }
        //枚举所有未匹配点,找增广路径,直到找不到增广路径.这里枚举的是女生的集合M.
        for(int i=1;i<=m;i++){
            //这里vis建议用布尔数组,以为每个点都初始化,当n过大时建议用时间戳记录vis标记避免初始化vis数组
            memset(visit,false,sizeof(visit));
            if(dfs(i)) ans++;//搜索是否能找到新的增广路
        }
        printf("%d\n",ans);
    }
    return 0;
}

/*
摘自http://www.renfei.org/blog/bipartite-matching.html
//匈牙利算法的bfs版本,有点复杂吧,实际效率比dfs高不了多少,有点没必要
//大概看了一下,还是模拟增广路径,设置一些前驱节点记录增广路径
//两个版本的时间复杂度均为O(V⋅E).DFS的优点是思路清晰、代码量少,但是性能不如BFS.
//我测试了两种算法的性能.对于稀疏图,BFS版本明显快于DFS版本;
//而对于稠密图两者则不相上下.在完全随机数据9000个顶点4,0000
//条边时前者领先后者大约97.6%,9000个顶点100,0000条边时前者领先后者8.6%,
//而达到500,0000条边时BFS仅领先0.85%.
//下面代码是https://www.cnblogs.com/zpfbuaa/p/7218607.html
//优点:适用于稀疏二分图,边较少,增广路较短.匈牙利算法的理论复杂度是O(VE).
#include<iostream>
#include<memory.h>
using namespace std;

#define MAXN 10
int graph[MAXN][MAXN];
//在bfs中，增广路径的搜索是一层一层展开的，所以必须通过prevX来记录上一层的顶点
//chkY用于标记某个Y顶点是否被目前的X顶点访问尝试过。
int matchX[MAXN], matchY[MAXN], prevX[MAXN], chkY[MAXN];
int queue[MAXN];
int nx, ny;

int bfsHungarian()
{
    int res = 0;
    int qs, qe;
    memset( matchX, -1, sizeof(matchX) );
    memset( matchY, -1, sizeof(matchY) );
    memset( chkY, -1, sizeof(chkY) );

    for( int i=0; i<nx; i++ )
    {
        if( matchX[i] == -1 )   //如果该X顶点未找到匹配点，将其放入队列。
        {
            qs = qe = 0;
            queue[qe++] = i;
            prevX[i] = -1;  //并且标记，它是路径的起点
            bool flag = 0;

            while( qs<qe && !flag )
            {
                int u = queue[qs];
                for( int v=0; v<ny&&!flag; v++ )
                {
                    if( graph[u][v] && chkY[v]!=i ) //如果该节点与u有边且未被访问过
                    {
                        chkY[v] = i;    //标记且将它的前一个顶点放入队列中，也就是下次可能尝试这个顶点看能否为它找到新的节点
                        queue[qe++] = matchY[v];
                        if( matchY[v] >= 0 )
                            prevX[matchY[v]] = u;
                        else    //到达了增广路径的最后一站
                        {
                            flag = 1;
                            int d=u, e=v;
                            while( d!=-1 )  //一路通过prevX找到路径的起点
                            {
                                int t = matchX[d];
                                matchX[d] = e;
                                matchY[e] = d;
                                d = prevX[d];
                                e = t;
                            }
                        }
                    }
                }
                qs++;
            }
            if( matchX[i] != -1 )
                res++;
        }
    }
    return res;
}
*/
