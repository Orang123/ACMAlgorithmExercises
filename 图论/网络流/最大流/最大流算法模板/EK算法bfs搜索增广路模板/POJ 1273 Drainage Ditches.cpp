#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define N 210
#define INF 0x3f3f3f3f
using namespace std;
//ac 0ms EK算法 bfs搜索一条最短增广路 邻接矩阵存边
/*
参考博客:https://blog.csdn.net/stevensonson/article/details/79177530
https://www.cnblogs.com/findview/p/11314610.html
相关概念:
最大流:
最大流问题(maximum flow problem),一种组合最优化问题,就是要讨论如何充分利用装置的能力,
使得运输的流量最大,以取得最好的效果.求最大流的标号算法最早由福特和福克逊于1956年提出,
20世纪50年代福特(Ford)、(Fulkerson)建立的“网络流理论”,是网络应用的重要组成成分.
运输网络的一个主要问题就是找出它的一个最大流fmax,最大流表示在尽量满足条件的情况下,
网络中各条干线上的最大运输量.

1.网络流:有向图G=(V,E)中:
(1).有唯一的一个源点s(入度为0,出发点);
(2).唯一的一个汇点t(出度为0,结束点);
(3).图中每条弧(u,v)都有一非负容量c(u,v);
满足上述条件的图G称为网络流图.记作:G=(V,E,C);除过s、t外的其余点叫作中间点.
网络流图是一张只有一个源点和汇点的有向图,而最大流就是求源点到汇点间的最大水流量.
2.流f(u,v)定义在二元组(u属于V,v属于V)上的实数函数需满足:
(1).容量限制:对于每条边,流经该边的流量不得超过该边的容量,即:f(u,v)<=c(u,v);
(2).斜对称性:每条边的流量与其相反边的流量之和为0,即:f(u,v)=-f(v,u);
(3).流守恒性:从源点流出的流量等于汇点流入的流量;
3.剩余容量(残余容量):1条边的剩余容量cf(u,v),它表示的是这条边的容量与流量之差,
即cf(u,v)=c(u,v)-f(u,v).f(u,v),代表通过有向边u->v上的当前流量.
对于弧(u,v)来说,流量就是其上流过的水量(我们通常用f(u,v)表示),
而容量就是其上可流过的最大水量(我们通常用c(u,v)表示),
只要满足0<f(u,v)<=c(u,v),我们就称流量f(u,v)是可行流.
4.正向边:从s到t的一条简单路径,若边(u,v)的方向与该路径的方向一致,称(u,v)
为正向边,方向不一致时称为反向边.
5.残余网络:对于流函数f,残存网络Gf是网络G中所有结点和剩余容量大于0的边构成的子图.
6.增广路:在原图G中若一条从源点到汇点的路径上所有边的剩余容量都大于0,这条路被称为增广路.
或如果一条从s到t的简单路径上的所有边均满足:
正向边:f(u,v)<=c(u,v)或反向边:f(u,v)>0,则这条路径称为增广路.
即一条从源点s到汇点t的路径中不包括残余容量为0的边称为增广路,增广路径中不存在剩余容量为0的边.
7.反向弧理论:
在搜索增广路的时候建造反向边,原因是这条路不一定是最优的,这样子程序可以进行反悔.
对于每次选择的一条有向边上的残余容量都要减去路径上的最小残量的同时,为这两个相邻
的点添加一条反向弧,反向弧的残余容量加上最小残量的数值,这样就可提供反悔的机会.
反向弧是现实中不存在的有向流,但最终所计算的最大流是正确的.
参见草稿纸"最短增广路反向弧理论清晰版.jpg".关于反向弧理论的正确性可从能量守恒的
角度去理解,能量既不会凭空产生,也不会凭空消失,正向边有水流,反向边就会对应产生反向
的水流,这样正反水流刚好抵消掉,它的正确性应该也是建立在这个相互抵消的基础上的.
反向弧理论在离散数学图论中有十分严格的证明,这里不详细展开.
8.割:网络N的一个割即是分离源和汇的弧之集合.割K的容量记作:C(K).
若网络中不存在其他割的容量比割K的容量小,则割K称作网格N的最小割Kmin.
相关结论:
(1).割是网络上的咽喉要道,割的容量自然会制约着网络上的流.
实际上最小割的容量就是网络的最大流.
(2).网络中的流值不超过最小割的容量.
(3).最大流最小割定理:网络中最大流量等于网络中最小的割的容量.证明不详细讲述.
*/

/*
最大流算法:
1.FF(Ford-Fulkerson)增广路算法:该方法通过寻找增广路来更新最大流,有EK,dinic,SAP,ISAP主流算法.
Ford-Fulkerson算法是一种贪婪算法,用于计算流网络中的最大流量.贪心是指每次记录增广路中边的最小残余容量.
它被称为“方法”而不是“算法”,因为在残差图中找到增广路径的方法没有完全指定,
或者在具有不同运行时间的若干实现中指定.它由L.R.Ford,Jr.和D.R.Fulkerson于1956年出版.
名称“Ford-Fulkerson”通常也用于Edmonds-Karp算法,该算法是Ford-Fulkerson方法的完全定义的实现.

注意:FF算法提出了关于最大流算法的残余网络概念,运用反向弧依据更新增广路剩余容量贪心思维,
以及相关理论最大流最小割定理,但还没提供增广路的搜索方案,没有标程.

2.EK(Edmond-Karp)动能算法:时间复杂度:O(V*E^2)这个时间复杂度不太能直观看出,可能需要相关严格性的证明.
从S点出发不断找一条到T的增广路的过程,我们通过BFS向周围搜索与S直接相连的剩余流量不为0的节点
(这个节点一定要是没走过的,因为一条增广路每个点肯定只出现了一次),将他们加入队列,每次从队列中
取出一个元素继续向周围查询,直到目标点为T点,且这一条道路上不包含流量为0的水管,则说明这是一条增广路,
为沿途的所有节点两两之间的剩余流量减去该条增广路的最小残量,而同时为它们的反向弧加上最小残量,
不断循环直到无法从S点到T找到一条增广路为止.
注意:EK算法每次bfs只能找到一条增广路,
(1).找?我们就从源点一直BFS走来走去,碰到汇点就停,一次只能找到一条增广路,记录这条路径上最小的残余容量incf.
在BFS的时候要注意残余容量是否大于0,边是否为有效边,即:cf(u,v)>0.
(2).增广?其实就是按照我们找的增广路在反向更新残余容量.使得正向边的残余容量较少incf,反向边的残余容量增加incf.
直到回到增广路起点s,最大流结果加上这条增广路上的最小残余容量incf.再次搜索新的增广路.

EK算法相比FF算法优点:
EK算法搜索增广路采用bfs最先搜索路径较短的增广路,这可在一定程度上规避先搜索到较长的增广路,导致后续使用
反向弧反悔造成最终的增广路路径长度偏大,最终算法的复杂度会加大,实际上最大流的值是恒定的,但搜索的所有增广路
组合方案并不唯一,所以要提高搜索效率,就应尽可能搜索到长度较短增广路来求解最大流.

3.Dinic算法:时间复杂度O(V^2*E)
Dinic算法是网络流最大流的优化算法之一,先BFS对原图进行分层,
设源点的层数为0,那么一个点的层数便是它离源点的最近距离,然后用DFS求增广路.
时间复杂度是O(V^2*E)(需要严格地证明),相比EK的O(V*E^2)还是快得多了,因为边数要远远多于顶点数.
Dinic算法最多被分为n个阶段,每个阶段包括建层次网络和寻找增广路两部分.Dinic算法的思想是分阶段地在层次网络中增广.
它与最短增广路算法(EK)不同之处是;最短增广路每个阶段执行完一次BFS增广后(每次只会增广一条路径),要重新启动BFS从
源点st开始寻找另一条增广路;而在Dinic算法中,每次BFS过程就可以实现多次增广,即BFS构建层次网络,DFS完成多路增广,
层次网络指的是多条长度相同的增广路,而且是在本次BFS中最短的增广路,参考点是第一次到达汇点的那条路径的长度,
之后到达汇点的增广路长度需与其一致.
Dinic在稀疏图上效率和EK算法相当,但在稠密图上效率要比EK算法高很多.
*/

/*
题意:n个池塘,m条水渠,每条水渠水的流向只能是一个方向,
每条水渠有个水流的速率,求水渠中从1点流向n点(溪流)的水
流的最大速率.
释义:n个点,m条有向边的网络,每条边有一定容量,求解1到n的最大流.
注意:输入会有重复边,即1->2 20 1->2 30,这样1->2实际容量为30,
因此要累加容量.
链接:http://poj.org/problem?id=1273
思路:EK算法求解最大流模板.
*/

/*
net代表残余网络中有向边的残余容量,采用邻接矩阵存储;
pre[i]记录i点的前驱节点;
incf[i]代表从源点s到点i的路径所有边中最小的残余容量;incf(in capacity flow)
*/
int net[N][N],n,m,pre[N],incf[N];

//s为源点 t为汇点 bfs每次找到的增广路一定是最短的.此题1为源点,n为汇点.
int bfs(int s,int t){//O(V+E)
    int u;
    queue<int> Q;
    incf[s]=INF;
    memset(pre,-1,sizeof(pre));//初始化所有点的前驱节点为-1 编号不从0开始,初始化为0也是可以的,pre[v]==0
    //pre[s]=s//如果下面遍历时v是从1开始遍历,这里就需要标记源点1的前驱已访问,否则1点可能会入队
    Q.push(s);//加入源点
    while(!Q.empty()){
        u=Q.front();
        Q.pop();
        //这里一般应过滤掉源点s,此题源点编号为1,所以下界从2开始.
        for(int v=2;v<=n;v++){
            //该边的残余容量要可用(大于0) 该点之前必须未被访问(pre[v]==-1) 对于反向弧,无需标记vis,避免其又返回s点bfs,因为反向弧pre[v]!=-1.
            if(net[u][v]>0 && pre[v]==-1){
                incf[v]=min(incf[u],net[u][v]);//记录该增广路中最小的残余容量
                pre[v]=u;//pre记录增广路中该点的前驱节点
                if(v == t)//到达汇点时构成一条可增广路,返回
                    return incf[t];
                Q.push(v);
            }
        }
    }
    return -1;//当网络中不存在增广路时,已求出最大流,结束
}

//累加每条增广路中最小残余容量作为最大流的最终结果
int maxFlow(){//O(VE^2)
    int sum=0,q;
    while(bfs(1,n)!=-1){//O(V)*O(V+E) 返回-1时代表原图中所有路径中都至少存在一条残余容量为0的边,即没有搜索到增广路.
        q=n;
        //q==-1代表回到源点s
        while(q!=1){//O(E) 最坏情况每条边都构成一条增广路 更新该增广路上每条边的残余容量
            net[pre[q]][q]-=incf[n];//t汇点编号为m
            /*
            与此同时构造反向弧,这会给计算提供一个后悔和改进的可行边,当某条增广路的选择
            不是最优时,再次搜索增广路残余流量到达上限时,就可利用这条反向弧构造现实中可
            能不存在的增广路,但最终所计算的最大流是正确的,流向一正一反,可理解为相互抵消,
            两个点之间可假想成紧挨着不存在边的情况("反向弧两端点转化为紧挨.jpg"草稿上),
            这个反向弧的提出应用了 离散数学最大流最小割定理去证明其正确性,这条反向弧原先
            的正向弧残余容量最大或最小都会影响最优增广路的选择 更取决于相邻边的残余容量是
            多少来决定相邻边是否会阻塞周围边构成新的增广路.
            */
            net[q][pre[q]]+=incf[n];
            q=pre[q];
        }
        sum+=incf[n];//最大流累加最小残余容量
    }
    return sum;
}

int main(){
    int x,y,cap;
    while(scanf("%d %d",&m,&n)!=EOF){
        memset(net,0,sizeof(net));
        for(int i=1;i<=m;i++){
            scanf("%d %d %d",&x,&y,&cap);
            net[x][y]+=cap;//有重复边,累加容量
        }
        printf("%d\n",maxFlow());
    }
    return 0;
}

/*
//ac 0ms bfs每次搜索一条最短增广路 链式前向星存双向边(正向弧和反向弧)
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#define N 210
#define INF 0x3f3f3f3f
using namespace std;

int cnt,n,m,pre[N],incf[N],head[N];
//这里题目中说明了 最多有N(210)条水管,因为在构建网络时需要初始化反向弧,所以需要构造无向图,存双向边(正向弧和反向弧)
//所以总共需要的最大边数为2*N 不知为何POJ这里最大长度设为N 也不会报runerror 数组越界
struct node{
    int to,next,c;
}net[N<<1];

void addEdge(int x,int y,int c){
    net[cnt].to=y;
    net[cnt].c+=c;//因为有重复边所以要累加容量,不累加好像也能ac,不知啥原因
    net[cnt].next=head[x];
    head[x]=cnt++;
}

int bfs(int s,int t){
    int p,v;
    queue<int> Q;
    memset(pre,-1,sizeof(pre));
    pre[s]=s;//源点1的前驱需要标记已访问,避免搜索增广路再被访问
    incf[s]=INF;
    Q.push(s);
    while(!Q.empty()){
        p=Q.front();
        Q.pop();
        for(int i=head[p];i!=-1;i=net[i].next){
            v=net[i].to;
            if(net[i].c>0 && pre[v]==-1){//对于反向弧,无需标记vis 避免其又返回s点dfs,因为有pre[v]限制 但s点的起始边的反向弧还是会再次访问
                incf[v]=min(incf[p],net[i].c);
                pre[v]=i;//这里记录的是net 边下标,真实的前驱节点需要根据异或运算求相邻反向弧
                if(v==t)
                    return incf[t];
                Q.push(v);
            }
        }
    }
    return -1;
}

int maxFlow(){
    int sum=0,q;
    while(bfs(1,m)!=-1){
        q=m;
        while(q!=1){
            net[pre[q]].c-=incf[m];
            //采用异或操作将 偶数下标变奇数下标,奇数变偶数,若本身是较小的正向边则会变为小标+1的反向边,
            //若本身是反向边则会变为小标-1的正向边
            net[pre[q]^1].c+=incf[m];
            q=net[pre[q]^1].to;//根据与其紧邻的反向边可求出q的前驱节点
        }
        sum+=incf[m];
    }
    return sum;
}

int main(){
    int x,y,cap;
    while(scanf("%d %d",&n,&m)!=EOF){
        cnt=0;
        memset(head,-1,sizeof(head));
        memset(net,0,sizeof(net));//因为要累加容量,所以容量c初始化为0
        while(n--){
            scanf("%d %d %d",&x,&y,&cap);
            addEdge(x,y,cap);//从cnt=0下标开始存边 每存一条正向边与他紧邻的cnt+1下标就存一条反向边 且参与容量初始化为0
            addEdge(y,x,0);
        }
        printf("%d\n",maxFlow());
    }
    return 0;
}
*/
